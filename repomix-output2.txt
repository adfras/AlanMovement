This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
AlanMovement.uproject
Config/DefaultEngine.ini
Config/DefaultGame.ini
Config/DefaultInput.ini
Plugins/OculusXRMovement/Config/DefaultOculusXRMovement.ini
Plugins/OculusXRMovement/OculusXRMovement.uplugin
Plugins/OculusXRMovement/Source/OculusXRMovement/OculusXRRetargeting.Build.cs
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXRBodyTracking.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXREyeTracking.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXRFaceTracking.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRAnimNodeBodyRetargeter.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRAnimNodeBodyRetargeter.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargeting.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargetingUtils.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargetSkeleton.cpp
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXRBodyTracking.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXREyeTracking.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXRFaceTracking.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRBodyRetargeter.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargeting.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargetingUtils.h
Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargetSkeleton.h
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/OculusXRRetargetingEditor.Build.cs
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRFacialExpressionMapFactory.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRRetargetIKRetargeterEditor.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRRetargetingEditor.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRFacialExpressionMapFactory.h
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRRetargetIKRetargeterEditor.h
Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRRetargetingEditor.h
Plugins/OculusXRMovement/Source/OculusXRMovementGraph/OculusXRRetargetingGraph.Build.cs
Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Private/OculusXR_TrackingGraphNodes.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Private/OculusXRRetargetingGraph.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Public/OculusXR_TrackingGraphNodes.h
Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Public/OculusXRRetargetingGraph.h
Plugins/OculusXRMovement/Source/OculusXRMovementTests/OculusXRRetargetingTests.Build.cs
Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/OculusXRRetargetingTests.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/RetargetingSkeletonTests.cpp
Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/RetargetingSkeletonTests.h
Plugins/OculusXRMovement/Source/OculusXRMovementTests/Public/OculusXRRetargetingTests.h
Source/AlanMovement.Target.cs
Source/AlanMovement/AlanMovement.Build.cs
Source/AlanMovement/AlanMovement.cpp
Source/AlanMovement/AlanMovement.h
Source/AlanMovement/Private/OculusXRFaceCorrectiveNamingScheme.cpp
Source/AlanMovement/Private/OculusXRFaceCorrectiveNamingScheme.h
Source/AlanMovement/Private/OculusXRFaceCorrectives.cpp
Source/AlanMovement/Private/OculusXRFaceCorrectives.h
Source/AlanMovement/Private/OculusXRFaceTrackingCorrectives.cpp
Source/AlanMovement/Private/OculusXRFaceTrackingCorrectives.h
Source/AlanMovementEditor.Target.cs

================================================================
Files
================================================================

================
File: .gitignore
================
# Ignore Intermediate files
Binaries/
Build/
DerivedDataCache/
Intermediate/
Saved/

# Ignore Intermediate plugin files
/Plugins/*/Intermediate
/Plugins/Developer/*/Intermediate

# Ignore plugin binaries
/Plugins/**/Binaries

# IDEs
.vs/
.vscode/
.vsconfig
.idea/

# Solution file
*.sln

================
File: AlanMovement.uproject
================
{
	"FileVersion": 3,
	"EngineAssociation": "5.5",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "AlanMovement",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true,
			"TargetAllowList": [
				"Editor"
			]
		},
		{
			"Name": "OculusXR",
			"Enabled": true
		}
	]
}

================
File: Config/DefaultEngine.ini
================
[/Script/EngineSettings.GameMapsSettings]
GameDefaultMap=/Engine/Maps/Templates/OpenWorld
GlobalDefaultGameMode=/Game/Blueprints/BP_MovementSampleGameMode.BP_MovementSampleGameMode_C
GameInstanceClass=/Game/Blueprints/BP_GameInstance.BP_GameInstance_C

[/Script/Engine.RendererSettings]
r.AllowStaticLighting=True

r.GenerateMeshDistanceFields=True

r.DynamicGlobalIlluminationMethod=1

r.ReflectionMethod=1

r.SkinCache.CompileShaders=True

r.RayTracing=True

r.Shadow.Virtual.Enable=1

r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True

r.DefaultFeature.LocalExposure.HighlightContrastScale=0.8

r.DefaultFeature.LocalExposure.ShadowContrastScale=0.8
r.Mobile.AntiAliasing=3
r.MSAACount=4
r.MobileHDR=False
vr.MobileMultiView=True
vr.InstancedStereo=True
r.ForwardShading=True
r.Mobile.UseHWsRGBEncoding=True

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1

[/Script/LinuxTargetPlatform.LinuxTargetSettings]
-TargetedRHIs=SF_VULKAN_SM5
+TargetedRHIs=SF_VULKAN_SM6

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/WorldPartitionEditor.WorldPartitionEditorSettings]
CommandletClass=Class'/Script/UnrealEd.WorldPartitionConvertCommandlet'

[/Script/Engine.UserInterfaceSettings]
bAuthorizeAutomaticWidgetVariableCreation=False
FontDPIPreset=Standard
FontDPI=72

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_Blank",NewGameName="/Script/AlanMovement")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_Blank",NewGameName="/Script/AlanMovement")

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=D17A545F4AB0B6EA14AC4A9D4C56B20E
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/AndroidRuntimeSettings.AndroidRuntimeSettings]
MinSDKVersion=32
TargetSDKVersion=32
bPackageForMetaQuest=True
bSupportsVulkanSM5=False
bBuildForES31=False
ExtraApplicationSettings=<meta-data android:name="com.oculus.supportedDevices" android:value="quest|quest2|questpro|quest3" />

[/Script/OculusXRHMD.OculusXRHMDRuntimeSettings]
ColorSpace=Quest
HandTrackingSupport=HandsOnly
HandTrackingFrequency=HIGH
bBodyTrackingEnabled=True
bEyeTrackingEnabled=True
bFaceTrackingEnabled=True
bSupportExperimentalFeatures=True

================
File: Config/DefaultGame.ini
================
[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=E6160D7249C03DBE772AA9892AE7EF04
bStartInVR=True

================
File: Config/DefaultInput.ini
================
[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bShouldFlushPressedKeysOnViewportFocusLost=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=None
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde

================
File: Plugins/OculusXRMovement/Config/DefaultOculusXRMovement.ini
================
[CoreRedirects]
+StructRedirects=(OldName="/Script/OculusRetargeting.OculusRetargetFacialExpressionDataTableRow",NewName="/Script/OculusXRRetargeting.OculusXRFacialExpressionMapRow")
+ClassRedirects=(OldName="/Script/OculusRetargeting.OculusRetargetFacialExpressionDataTable",NewName="/Script/OculusXRRetargeting.OculusXRFacialExpressionMap")
+StructRedirects=(OldName="/Script/OculusRetargeting.OculusRetargetFacialExpressionToAnimationCurve",NewName="/Script/OculusXRRetargeting.OculusXRFacialExpressionToAnimationCurve")
+ClassRedirects=(OldName="/Script/OculusRetargetingEditor.OculusRetargetFacialExpressionToAnimationCurveEditor",NewName="/Script/OculusXRRetargetingEditor.OculusXRFacialExpressionToAnimationCurveEditor")
+StructRedirects=(OldName="/Script/OculusRetargeting.OculusRetargetFromMesh",NewName="/Script/OculusXRRetargeting.OculusXRRetargeterAnimNode")
+ClassRedirects=(OldName="/Script/OculusRetargetingEditor.OculusRetargetFromMeshEditor",NewName="/Script/OculusXRRetargetingEditor.OculusXRRetargetIKRetargeterEditor")
+ClassRedirects=(OldName="/Script/OculusRetargetingEditor.OculusRetargetFacialExpressionDataTableFactory",NewName="/Script/OculusXRRetargetingEditor.OculusXRFacialExpressionMapFactory")
+ClassRedirects=(OldName="/Script/OculusXRRetargetingGraph.OculusXRBodyTracking",NewName="/Script/OculusXRRetargetingGraph.OculusXR_BodyRetargeting")
+ClassRedirects=(OldName="/Script/OculusXRRetargetingGraph.OculusXR_AutoRetargeting",NewName="/Script/OculusXRRetargetingGraph.OculusXR_BodyRetargeting")
+StructRedirects=(OldName="/Script/OculusXRRetargeting.AnimNode_AutoRetargeting",NewName="/Script/OculusXRRetargeting.AnimNode_OculusXRBodyTracking")
+PropertyRedirects=(OldName="/Script/OculusXRRetargeting.SkeletonDebugSettings.SourceSkeleton",NewName="/Script/OculusXRRetargeting.SkeletonDebugSettings.SourceSkeletonRestPose")
+PropertyRedirects=(OldName="/Script/OculusXRRetargeting.AnimNode_OculusXRBodyTracking.IsTPosing",NewName="/Script/OculusXRRetargeting.AnimNode_OculusXRBodyTracking.AutoCorrectNonTPose")

================
File: Plugins/OculusXRMovement/OculusXRMovement.uplugin
================
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "OculusXRMovement",
	"Description": "Provides animation nodes that allow you to use Meta’s movement features from within Unreal’s Animation Graph",
	"Category": "Other",
	"CreatedBy": "Meta Platforms, Inc.",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "OculusXRRetargeting",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		{
			"Name": "OculusXRRetargetingGraph",
			"Type": "UncookedOnly",
			"LoadingPhase": "Default"
		},
		{
			"Name": "OculusXRRetargetingTests",
			"Type": "DeveloperTool",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"OculusXRRetargeting",
				"OculusXRMovement"
			]
		}
	],
	"Plugins": [
		{
			"Name": "IKRig",
			"Enabled": true
		},
		{
			"Name": "OculusXR",
			"Enabled": true
		}
	]
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/OculusXRRetargeting.Build.cs
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

using UnrealBuildTool;

public class OculusXRRetargeting : ModuleRules
{
    public OculusXRRetargeting(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
                "IKRig",
                "OculusXRMovement",
                "AnimGraphRuntime",
            }
        );


        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
                "Slate",
                "SlateCore",
                "LiveLinkInterface",
                "LiveLinkAnimationCore",
                "OculusXRMR",
            }
        );
    }
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXRBodyTracking.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "AnimNode_OculusXRBodyTracking.h"
#include "OculusXRAnimNodeBodyRetargeter.h"
#include "OculusXRMovement.h"
#include "OculusXRMRFunctionLibrary.h"
#include "OculusXRRetargeting.h"
#include "Animation/AnimInstanceProxy.h"
#include "OculusXRRetargetingUtils.h"
#include "DrawDebugHelpers.h"

void FAnimNode_OculusXRBodyTracking::Initialize_AnyThread(const FAnimationInitializeContext& Context)
{
	InputPose.Initialize(Context);

	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}

	SkeletalMeshComponent = Context.AnimInstanceProxy->GetSkelMeshComponent();

	if (SkeletalMeshComponent == nullptr)
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("SkeletalMeshComponent is null"))

	if (!FOculusXRRetargetingUtils::GetUnitScaleFactorFromSettings(SkeletalMeshComponent->GetWorld(), Scale))
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("Cannot get world settings for body retargetting asset."));
	}
}

void FAnimNode_OculusXRBodyTracking::PreUpdate(const UAnimInstance* InAnimInstance) {}

void FAnimNode_OculusXRBodyTracking::Evaluate_AnyThread(FPoseContext& Output)
{
	InputPose.Evaluate(Output);
	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}

	FOculusXRBodyState BodyState;
	OculusXRMovement::GetBodyState(BodyState, Scale);

	if (!RetargeterInstance)
	{
		RetargeterInstance = TSharedPtr<FOculusXRBodyRetargeter>(reinterpret_cast<FOculusXRBodyRetargeter*>(new FOculusXRAnimNodeBodyRetargeter()));
		RetargeterInstance->Initialize(RetargetingMode, RootMotionBehavior, ForwardMesh, &BoneRemapping);
	}
	if (RetargetingMode != RetargeterInstance->GetRetargetingMode() || RootMotionBehavior != RetargeterInstance->GetRootMotionBehavior())
	{
		RetargeterInstance->Initialize(RetargetingMode, RootMotionBehavior, ForwardMesh, &BoneRemapping);
	}
	if (!RetargeterInstance->RetargetFromBodyState(BodyState, SkeletalMeshComponent, Scale, Output))
	{
		if (SkeletalMeshComponent && SkeletalMeshComponent->GetWorld()->IsGameWorld())
		{
			UE_LOG(LogOculusXRRetargeting, Warning, TEXT("No valid delta rotations or skeletons"));
		}
	}
	RetargeterInstance->SetDebugPoseMode(DebugPoseMode);
	RetargeterInstance->SetDebugDrawMode(DebugDrawMode);
}

void FAnimNode_OculusXRBodyTracking::Update_AnyThread(const FAnimationUpdateContext& Context)
{
	InputPose.Update(Context);
	// Evaluate pin inputs
	GetEvaluateGraphExposedInputs().Execute(Context);
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXREyeTracking.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "AnimNode_OculusXREyeTracking.h"
#include "OculusXRMovement.h"
#include "OculusXRMRFunctionLibrary.h"
#include "OculusXRRetargeting.h"
#include "Animation/AnimInstanceProxy.h"
#include "OculusXRRetargetingUtils.h"

void FAnimNode_OculusXREyeTracking::Initialize_AnyThread(const FAnimationInitializeContext& Context)
{
	InputPose.Initialize(Context);

	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}
}

void FAnimNode_OculusXREyeTracking::PreUpdate(const UAnimInstance* InAnimInstance) {}

void FAnimNode_OculusXREyeTracking::Evaluate_AnyThread(FPoseContext& Output)
{
	InputPose.Evaluate(Output);

	FCSPose<FCompactPose> MeshPoses;
	MeshPoses.InitPose(Output.Pose);

	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}

	FBoneContainer BoneContainer = Output.Pose.GetBoneContainer();

	if (!HasSetInitialRotations)
		RecalculateInitialRotations(BoneContainer);

	FOculusXREyeGazesState GazesState;
	OculusXRMovement::GetEyeGazesState(GazesState);

	// Left eye

	uint32 LeftEyeIndex = BoneContainer.GetPoseBoneIndexForBoneName(LeftEyeBone);

	if (LeftEyeIndex != INDEX_NONE)
	{
		FCompactPoseBoneIndex LeftEyeId = BoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(LeftEyeIndex));

		FTransform CurrentTransform = MeshPoses.GetComponentSpaceTransform(LeftEyeId);
		FTransform GazeTransform = FTransform(GazesState.EyeGazes[0].Orientation, FVector::ZeroVector);

		CurrentTransform.SetRotation(GazeTransform.GetRotation() * InitialLeftRotation);
		MeshPoses.SetComponentSpaceTransform(LeftEyeId, CurrentTransform);
	}

	// Right eye

	uint32 RightEyeIndex = BoneContainer.GetPoseBoneIndexForBoneName(RightEyeBone);

	if (RightEyeIndex != INDEX_NONE)
	{
		FCompactPoseBoneIndex RightEyeId = BoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(RightEyeIndex));

		FTransform CurrentTransform = MeshPoses.GetComponentSpaceTransform(RightEyeId);
		FTransform GazeTransform = FTransform(GazesState.EyeGazes[1].Orientation, FVector::ZeroVector);

		CurrentTransform.SetRotation(GazeTransform.GetRotation() * InitialRightRotation);
		MeshPoses.SetComponentSpaceTransform(RightEyeId, CurrentTransform);
	}

	FCSPose<FCompactPose>::ConvertComponentPosesToLocalPosesSafe(MeshPoses, Output.Pose);
}

void FAnimNode_OculusXREyeTracking::Update_AnyThread(const FAnimationUpdateContext& Context)
{
	InputPose.Update(Context);
}

void FAnimNode_OculusXREyeTracking::RecalculateInitialRotations(FBoneContainer BoneContainer)
{
	const auto BoneIds = new TArray<FCompactPoseBoneIndex>;
	const auto ParentIndices = new TArray<int>;
	const auto ComponentTransforms = new TArray<FTransform>;
	const auto LocalTransforms = new TArray<FTransform>;

	// Get full skeleton
	const auto TargetReferenceSkeleton = BoneContainer.GetReferenceSkeleton();

	// Get bones used in current LOD
	const auto BoneIndicesArray = BoneContainer.GetBoneIndicesArray();

	for (int i = 0; i < BoneIndicesArray.Num(); ++i)
	{
		// BoneIndex = Index in full skeleton, only used to get transform, not parent
		// BoneId = Index in bone container / LOD skeleton, used to find correct parent index

		const auto BoneIndex = BoneIndicesArray[i];
		const auto BoneId = BoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(BoneIndex));
		const auto ParentBoneIndex = BoneContainer.GetParentBoneIndex(BoneId);
		const auto LocalBoneTransform = TargetReferenceSkeleton.GetRawRefBonePose()[BoneIndex];

		BoneIds->Add(BoneId);
		ParentIndices->Add(BoneIds->Find(ParentBoneIndex));
		LocalTransforms->Add(LocalBoneTransform);
	}

	for (int i = 0; i < BoneIndicesArray.Num(); ++i)
	{
		const auto ParentBoneIndex = ParentIndices->operator[](i);
		const auto BoneLocalTransform = LocalTransforms->operator[](i);
		if (ParentBoneIndex == INDEX_NONE)
		{
			ComponentTransforms->Add(BoneLocalTransform);
		}
		else
		{
			const auto ParentBoneTransform = ComponentTransforms->operator[](ParentBoneIndex);
			ComponentTransforms->Add(BoneLocalTransform * ParentBoneTransform);
		}
	}

	auto LeftEyeIndex = BoneContainer.GetPoseBoneIndexForBoneName(LeftEyeBone);
	if (LeftEyeIndex != INDEX_NONE)
		InitialLeftRotation = ComponentTransforms->operator[](LeftEyeIndex).GetRotation();

	auto RightEyeIndex = BoneContainer.GetPoseBoneIndexForBoneName(RightEyeBone);
	if (RightEyeIndex != INDEX_NONE)
		InitialRightRotation = ComponentTransforms->operator[](RightEyeIndex).GetRotation();

	HasSetInitialRotations = true;
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/AnimNode_OculusXRFaceTracking.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "AnimNode_OculusXRFaceTracking.h"
#include "OculusXRMovement.h"
#include "OculusXRMRFunctionLibrary.h"
#include "OculusXRRetargeting.h"
#include "Animation/AnimInstanceProxy.h"
#include "OculusXRRetargetingUtils.h"

void FAnimNode_OculusXRFaceTracking::Initialize_AnyThread(const FAnimationInitializeContext& Context)
{
	InputPose.Initialize(Context);

	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}

	SkeletalMeshComponent = Context.AnimInstanceProxy->GetSkelMeshComponent();
}

void FAnimNode_OculusXRFaceTracking::PreUpdate(const UAnimInstance* InAnimInstance) {}

void FAnimNode_OculusXRFaceTracking::Evaluate_AnyThread(FPoseContext& Output)
{
	InputPose.Evaluate(Output);

	// This animation node is executed during the packaging step.
	// During that time, the MetaXR plugin is not available and any calls to it will crash the editor,
	// preventing the packaging process from completing.
	// To avoid this, we check if the plugin is available before calling any of its functions.
	const auto hmd = UOculusXRMRFunctionLibrary::GetTrackingSystem();
	if (hmd == nullptr)
	{
		UE_LOG(LogOculusXRRetargeting, Warning, TEXT("XR tracking is not loaded and available. Cannot retarget body at this time."));
		return;
	}

	FOculusXRFaceState FaceState;
	OculusXRMovement::GetFaceState(FaceState);

	for (int32 FaceExpressionIndex = 0; FaceExpressionIndex < FaceState.ExpressionWeights.Num(); ++FaceExpressionIndex)
	{
		const auto FaceExpression = static_cast<EOculusXRFaceExpression>(FaceExpressionIndex);
		if (ExpressionNames.Contains(FaceExpression))
		{
			auto ExpressionCurves = ExpressionNames[FaceExpression];
			float Value = FaceState.ExpressionWeights[FaceExpressionIndex];

			// Apply Facial Expression Modifiers
			if (ExpressionModifiers.Contains(FaceExpression))
			{
				FOculusXRFaceExpressionModifierNew Modifier = ExpressionModifiers[FaceExpression];
				Value = FMath::Clamp(Value * Modifier.Multiplier, Modifier.MinValue, Modifier.MaxValue);
			}

			for (const auto& CurveName : ExpressionCurves.CurveNames)
			{
				Output.Curve.Set(CurveName, Value);
			}
		}
	}
}

void FAnimNode_OculusXRFaceTracking::Update_AnyThread(const FAnimationUpdateContext& Context)
{
	InputPose.Update(Context);
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRAnimNodeBodyRetargeter.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRAnimNodeBodyRetargeter.h"
#include "OculusXRMovement.h"
#include "OculusXRRetargeting.h"
#include "OculusXRRetargetingUtils.h"

#define OCULUS_XR_DEBUG_DRAW_MODIFIED_ROOT_MOTION_BEHAVIOR (OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW && 0)

// Twist joints should diverge no more than 2 degrees from the joint they are aligned with
const float FOculusXRAnimNodeBodyRetargeter::kTWIST_JOINT_MIN_ANGLE_THRESHOLD = FMath::DegreesToRadians(2.0f);

const TArray<EOculusXRBoneID> FOculusXRAnimNodeBodyRetargeter::kALIGNABLE_HAND_JOINTS({
	EOculusXRBoneID::BodyLeftHandThumbMetacarpal,
	EOculusXRBoneID::BodyLeftHandThumbProximal,
	EOculusXRBoneID::BodyLeftHandThumbDistal,
	EOculusXRBoneID::BodyLeftHandThumbTip,
	EOculusXRBoneID::BodyLeftHandIndexMetacarpal,
	EOculusXRBoneID::BodyLeftHandIndexProximal,
	EOculusXRBoneID::BodyLeftHandIndexIntermediate,
	EOculusXRBoneID::BodyLeftHandIndexDistal,
	EOculusXRBoneID::BodyLeftHandIndexTip,
	EOculusXRBoneID::BodyLeftHandMiddleMetacarpal,
	EOculusXRBoneID::BodyLeftHandMiddleProximal,
	EOculusXRBoneID::BodyLeftHandMiddleIntermediate,
	EOculusXRBoneID::BodyLeftHandMiddleDistal,
	EOculusXRBoneID::BodyLeftHandMiddleTip,
	EOculusXRBoneID::BodyLeftHandRingMetacarpal,
	EOculusXRBoneID::BodyLeftHandRingProximal,
	EOculusXRBoneID::BodyLeftHandRingIntermediate,
	EOculusXRBoneID::BodyLeftHandRingDistal,
	EOculusXRBoneID::BodyLeftHandRingTip,
	EOculusXRBoneID::BodyLeftHandLittleMetacarpal,
	EOculusXRBoneID::BodyLeftHandLittleProximal,
	EOculusXRBoneID::BodyLeftHandLittleIntermediate,
	EOculusXRBoneID::BodyLeftHandLittleDistal,
	EOculusXRBoneID::BodyLeftHandLittleTip,
	EOculusXRBoneID::BodyRightHandThumbMetacarpal,
	EOculusXRBoneID::BodyRightHandThumbProximal,
	EOculusXRBoneID::BodyRightHandThumbDistal,
	EOculusXRBoneID::BodyRightHandThumbTip,
	EOculusXRBoneID::BodyRightHandIndexMetacarpal,
	EOculusXRBoneID::BodyRightHandIndexProximal,
	EOculusXRBoneID::BodyRightHandIndexIntermediate,
	EOculusXRBoneID::BodyRightHandIndexDistal,
	EOculusXRBoneID::BodyRightHandIndexTip,
	EOculusXRBoneID::BodyRightHandMiddleMetacarpal,
	EOculusXRBoneID::BodyRightHandMiddleProximal,
	EOculusXRBoneID::BodyRightHandMiddleIntermediate,
	EOculusXRBoneID::BodyRightHandMiddleDistal,
	EOculusXRBoneID::BodyRightHandMiddleTip,
	EOculusXRBoneID::BodyRightHandRingMetacarpal,
	EOculusXRBoneID::BodyRightHandRingProximal,
	EOculusXRBoneID::BodyRightHandRingIntermediate,
	EOculusXRBoneID::BodyRightHandRingDistal,
	EOculusXRBoneID::BodyRightHandRingTip,
	EOculusXRBoneID::BodyRightHandLittleMetacarpal,
	EOculusXRBoneID::BodyRightHandLittleProximal,
	EOculusXRBoneID::BodyRightHandLittleIntermediate,
	EOculusXRBoneID::BodyRightHandLittleDistal,
	EOculusXRBoneID::BodyRightHandLittleTip,
});

const TSet<EOculusXRBoneID> FOculusXRAnimNodeBodyRetargeter::GenerateTPoseJointSet()
{
	TSet<EOculusXRBoneID> BaseSet({ EOculusXRBoneID::BodyLeftArmLower,
		EOculusXRBoneID::BodyRightArmLower,
		EOculusXRBoneID::BodyLeftHandWrist,
		EOculusXRBoneID::BodyRightHandWrist,
		EOculusXRBoneID::BodyLeftHandPalm,
		EOculusXRBoneID::BodyRightHandPalm,
		EOculusXRBoneID::BodyLeftLowerLeg,
		EOculusXRBoneID::BodyLeftFootAnkle,
		EOculusXRBoneID::BodyRightLowerLeg,
		EOculusXRBoneID::BodyRightFootAnkle });

	BaseSet.Append(kALIGNABLE_HAND_JOINTS);

	return BaseSet;
}

const TSet<EOculusXRBoneID> FOculusXRAnimNodeBodyRetargeter::kTPOSE_ADJUSTABLE_JOINT_SET = GenerateTPoseJointSet();

// NOTE: This set is defined for joints that we skip alignment on during the T-Pose Alignment process.
// The metacarpel to proximal alignment of the tracking skeleton differs in both proportion and alignment from the rest
// pose of many skeletons.  So we need to skip these to get to align the fingers correctly.
// The Thumb doesn't have this same issue (on most hands) - so those are commented out, but left in as a reminder.
// Will revisit to see if there's a better technique for aligning the hands without changing the proportions through rotation
// (ie - ensuring the applied rotation is only against the relative forward/back vector based on the pose of the wrist).
const TSet<EOculusXRBoneID> FOculusXRAnimNodeBodyRetargeter::kTPOSE_SPECIAL_HANDLING_ADJUSTABLE_HAND_JOINTS({
	// EOculusXRBoneID::BodyLeftHandThumbProximal,
	EOculusXRBoneID::BodyLeftHandIndexProximal,
	EOculusXRBoneID::BodyLeftHandMiddleProximal,
	EOculusXRBoneID::BodyLeftHandRingProximal,
	EOculusXRBoneID::BodyLeftHandLittleProximal,
	// EOculusXRBoneID::BodyRightHandThumbProximal,
	EOculusXRBoneID::BodyRightHandIndexProximal,
	EOculusXRBoneID::BodyRightHandMiddleProximal,
	EOculusXRBoneID::BodyRightHandRingProximal,
	EOculusXRBoneID::BodyRightHandLittleProximal,
});

void FOculusXRAnimNodeBodyRetargeter::Initialize(
	const EOculusXRBodyRetargetingMode RetargetingMode,
	const EOculusXRBodyRetargetingRootMotionBehavior RootMotionBehavior,
	const EOculusXRAxis MeshForwardFacingDir,
	const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap)

{
	InitData.RetargetingMode = RetargetingMode;
	InitData.RootMotionBehavior = RootMotionBehavior;
	InitData.MeshForwardFacingDir = MeshForwardFacingDir;

	check(SourceToTargetNameMap && !SourceToTargetNameMap->IsEmpty());
	InitData.SourceToTargetNameMap = SourceToTargetNameMap;

	InitData.TargetFacingTransform = FOculusXRRetargetingUtils::DirectionTransform(MeshForwardFacingDir);
	InitData.TrackingSpaceToComponentSpace = FOculusXRRetargetingUtils::GetTrackingSpaceToComponentSpace(InitData.TargetFacingTransform);

	// Ensure we force an update to our Skeleton
	SourceReferenceInfo.Invalidate();
}

bool FOculusXRAnimNodeBodyRetargeter::IsInitialized() const
{
	return InitData.SourceToTargetNameMap && !InitData.SourceToTargetNameMap->IsEmpty();
}

bool FOculusXRAnimNodeBodyRetargeter::UpdateSkeleton(
	const FOculusXRBodyState& BodyState,
	const FBoneContainer& BoneContainer,
	const USkeletalMeshComponent* SkeletalMeshComponent,
	const float WorldScale)
{
	if (BodyState.IsActive && IsInitialized() && SourceReferenceInfo.RequiresUpdate(BodyState.SkeletonChangedCount, BoneContainer.GetSerialNumber()) && OculusXRMovement::GetBodySkeleton(SourceReferenceInfo.SourceReferenceSkeleton, WorldScale))

	{
#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
		DebugDrawUtility.ClearDrawQueue(kRestPoseDebugDrawCategory);
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW

		// Store the new serial number and Skeleton Change Count
		SourceReferenceInfo.BoneContainerSerialNumber = BoneContainer.GetSerialNumber();
		SourceReferenceInfo.SourceChangeCount = BodyState.SkeletonChangedCount;

		// We may have new mapping data, so we need to recalculate constants
		TargetToSourceMap = RecalculateMapping(BoneContainer, InitData.SourceToTargetNameMap);

		// Generate the Target Skeleton Rest Pose
		const FOculusXRRetargetSkeletonFCompactPoseBoneIndex TargetSkeletonRestPose = Factory::FromBoneContainer(BoneContainer);

		// Call AFTER Initialize Target Facing Direction
		// We need to determine the TrackingToComponentSpace Transform in that function
		SourceReferenceInfo.SourceSkeleton = Factory::FromOculusXRBodySkeleton(SourceReferenceInfo.SourceReferenceSkeleton, InitData.TrackingSpaceToComponentSpace);

		// Fill TargetSkeletonData
		const TArray<TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>>& TargetJointArray = TargetSkeletonRestPose.GetJointDataArray();

		// Reset our Tracking structures
		TargetAdjustedRestPoseData.PoseData.Empty(TargetJointArray.Num());
		SourceReferenceInfo.SourceToTargetIdxMap.Empty(SourceReferenceInfo.SourceToTargetIdxMap.Num());

		// TODO: T197814847 - Fix to be more bulletproof - Based on an assumption that the Joints are
		// sorted from Parent to Child.  If it isn't, then the Parent Transform/Index may not get calculated before the child.
		for (int i = 0; i < TargetJointArray.Num(); ++i)
		{
			// Child Joint Array will be populated later.
			const EOculusXRBoneID sourceJointID = TargetToSourceMap.Contains(TargetJointArray[i].BoneId) ? TargetToSourceMap[TargetJointArray[i].BoneId] : EOculusXRBoneID::None;
			TargetAdjustedRestPoseData.PoseData.Add({ TargetJointArray[i].BoneId,
				TargetJointArray[i].ParentIdx,
				TargetJointArray[i].LocalTransform,
				TargetJointArray[i].ComponentTransform,
				sourceJointID,
				static_cast<float>(TargetJointArray[i].LocalTransform.GetLocation().Length()) });

			if (sourceJointID != EOculusXRBoneID::None)
			{
				SourceReferenceInfo.SourceToTargetIdxMap.Add(sourceJointID, i);
			}

			// Populate parent child array
			const int ParentIdx = TargetAdjustedRestPoseData.GetParentBoneIndex(i);
			if (ParentIdx != INDEX_NONE)
			{
				TargetAdjustedRestPoseData.PoseData[ParentIdx].childJoints.Add(i);
			}
		}

		// Calculate the Ancestor Indexes
		const EOculusXRBoneID characterRootParent = SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyRoot) ? EOculusXRBoneID::BodyRoot : EOculusXRBoneID::BodyHips;
		if (SourceReferenceInfo.SourceToTargetIdxMap.Contains(characterRootParent))
		{
			// We need to start with the root joint, if it's not mappped, we need to output an error
			CalculateMappedAncestorValues(SourceReferenceInfo, INDEX_NONE, SourceReferenceInfo.SourceToTargetIdxMap[characterRootParent], TargetAdjustedRestPoseData);
		}
		else
		{
			UE_LOG(LogOculusXRRetargeting, Warning, TEXT("Root And Hip Joints are not mapped - T-Pose Alignment will not function correctly."));
		}

		SetTargetToTPose();

		CacheTwistJoints();

		ApplyScaleAndProportion();

		InitializeScaleAndOffsetData();

#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
		if (SkeletalMeshComponent && (DebugDrawMode == EOculusXRBodyDebugDrawMode::RestPose || DebugDrawMode == EOculusXRBodyDebugDrawMode::RestPoseWithMapping))

		{
			const FTransform& MeshTransform = SkeletalMeshComponent->GetComponentTransform();
			DebugDrawUtility.AddSkeleton(SourceReferenceInfo.SourceSkeleton, MeshTransform, FColor::Yellow, kRestPoseDebugDrawCategory);
			DebugDrawUtility.AddSkeleton(TargetAdjustedRestPoseData, MeshTransform, FColor::Green, kRestPoseDebugDrawCategory);

			// Draw the Mappings in White
			if (DebugDrawMode == EOculusXRBodyDebugDrawMode::RestPoseWithMapping)
			{
				DebugDrawUtility.AddSkeletonMapping(SourceReferenceInfo.SourceSkeleton, TargetAdjustedRestPoseData, SourceReferenceInfo.SourceToTargetIdxMap,
					MeshTransform, FColor::White, kRestPoseDebugDrawCategory);
			}
		}
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	}
#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	else if (!(DebugDrawMode == EOculusXRBodyDebugDrawMode::RestPose || DebugDrawMode == EOculusXRBodyDebugDrawMode::RestPoseWithMapping))

	{
		DebugDrawUtility.ClearDrawQueue(kRestPoseDebugDrawCategory);
	}
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	return SourceReferenceInfo.IsValid();
}

bool FOculusXRAnimNodeBodyRetargeter::ProcessFrameRetargeting(
	const FOculusXRBodyState& BodyState,
	const USkeletalMeshComponent* SkeletalMeshComponent,
	FPoseContext& Output)
{
	// Sanity Check - these should all be valid for this function to execute
	if (!(SkeletalMeshComponent && SourceReferenceInfo.IsValid()))
	{
		return false;
	}

	FCSPose<FCompactPose> MeshPoses;
	MeshPoses.InitPose(Output.Pose);
	TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>> FramePoses;

	FramePoses.Reserve(TargetAdjustedRestPoseData.GetNumBones());

#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	// Feature to Retarget to Rest Pose ONLY available in non-shipping builds
	if (DebugPoseMode == EOculusXRBodyDebugPoseMode::RestPose)
	{
		// Slam the Rest Pose into the Target
		for (int iBoneIdx = 0; iBoneIdx < TargetAdjustedRestPoseData.GetNumBones(); ++iBoneIdx)
		{
			const auto& jointEntry = TargetAdjustedRestPoseData.PoseData[iBoneIdx];
			FTransform jointFrameTransform = jointEntry.ComponentTransform;
			FramePoses.Add({ jointEntry.BoneId, jointFrameTransform, jointEntry.componentSpaceScale });
		}

		SourceReferenceInfo.LastFrameBodyState = SourceReferenceInfo.SourceSkeleton;
	}
	else
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	{
		// TODO: T197814847 - Longer Term - Fix to be more bulletproof - Based on an assumption that the Joints are
		// sorted from Parent to Child.  If it isn't, then the Parent Transform/Index may not get calculated before the child.

		// If the BodyState isn't active and we have a valid cached pose from last frame, use it to freeze the character in space
		// until the operations in the OS complete and we get valid data again.
		if (BodyState.IsActive)
		{
			SourceReferenceInfo.LastFrameBodyState = Factory::FromOculusXRBodyState(BodyState,
				SourceReferenceInfo.SourceReferenceSkeleton, InitData.TrackingSpaceToComponentSpace, InitData.RootMotionBehavior);
		}

		for (int iBoneIdx = 0; iBoneIdx < TargetAdjustedRestPoseData.GetNumBones(); ++iBoneIdx)
		{
			const auto& jointEntry = TargetAdjustedRestPoseData.PoseData[iBoneIdx];
			FTransform jointFrameTransform = jointEntry.ComponentTransform;
			if (jointEntry.ParentIdx != INDEX_NONE)
			{
				// Append the Local Transform (We will interpolate Twist Joint Chains later)
				check(jointEntry.ParentIdx < FramePoses.Num());
				const FTransform& parentTransform = FramePoses[jointEntry.ParentIdx].Get<FTransform>();
				jointFrameTransform = jointEntry.LocalTransform * parentTransform;
			}

			const int sourceJointIndex = SourceReferenceInfo.LastFrameBodyState.GetBoneIndex(jointEntry.sourceJointID);
			if (SourceReferenceInfo.LastFrameBodyState.IsValidIndex(sourceJointIndex))
			{
				// If we have a valid Mapping, then Apply the Mapping to Retarget the Joint
				FTransform retargetedJoint = jointEntry.sourceJointLocalOffset * SourceReferenceInfo.LastFrameBodyState.GetComponentTransform(sourceJointIndex);

				if (IsRotationOnlyRetargetingMode(InitData.RetargetingMode))
				{
					if (IsHipOrRootSourceJoint(jointEntry.sourceJointID))
					{
						jointFrameTransform = retargetedJoint;
					}
					else
					{
						jointFrameTransform.SetRotation(retargetedJoint.GetRotation());
					}
				}
				else
				{
					check(IsRotationAndPositionRetargetingMode(InitData.RetargetingMode));
					// If this is a hand joint and our alignment mode is something that doesn't scale the hands
					// then apply rotation only retargeting to the hand joints to avoid scaling them from the
					// hand tracking system.
					const int RightWristBoneIndex = SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyRightHandWrist) ? SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyRightHandWrist] : INDEX_NONE;
					const int LeftWristBoneIndex = SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyLeftHandWrist) ? SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyLeftHandWrist] : INDEX_NONE;

					if (InitData.RetargetingMode == EOculusXRBodyRetargetingMode::RotationAndPositionsHandsRotationOnly && (iBoneIdx == RightWristBoneIndex || TargetAdjustedRestPoseData.IsAncestorToBoneIndex(RightWristBoneIndex, iBoneIdx) || iBoneIdx == LeftWristBoneIndex || TargetAdjustedRestPoseData.IsAncestorToBoneIndex(LeftWristBoneIndex, iBoneIdx)))
					{
						jointFrameTransform.SetRotation(retargetedJoint.GetRotation());
					}
					else
					{
						// Check to see whether we need to modify the parent orientation due to deformation.
						if (!IsHipOrRootSourceJoint(jointEntry.sourceJointID) && jointEntry.ParentIdx != INDEX_NONE && jointEntry.sourceJointLocalOffset.GetLocation().Length() > 0.0f)
						{
							// Check to see if the parent only has one non-twist child joint.
							// We can rotate it if we're the only child joint that matters.
							const auto& parentJointEntry = TargetAdjustedRestPoseData.PoseData[jointEntry.ParentIdx];
							const int nonTwistChildJointCount = parentJointEntry.GetNonTwistChildJointCount();
							check(nonTwistChildJointCount > 0);
							if (parentJointEntry.GetNonTwistChildJointCount() == 1)
							{
								// We're only doing parent rotation here, then propagating to it's child twist joints.
								// We'll handle the twist joint spacing during the twist joint update below

								// NOTE: The twist joint pass also captures unmapped joints in a chain so that we can apply
								// twist interpolation.  We don't cache those joints or need to handle those in this pass
								// since a qualification of those joints is that they only have a single parent and have a
								// single child that terminates the chain.  There won't be a situation where a sibling joint
								// should/could affect their rotation.

								// Fix the Parent Rotation to re-align with our translated child joint
								FTransform& parentComponentTransform = FramePoses[jointEntry.ParentIdx].Get<FTransform>();
								FVector frameRayToCurrentJoint = retargetedJoint.GetLocation() - parentComponentTransform.GetLocation();
								FVector restPoseRayToCurrentJoint = jointFrameTransform.GetLocation() - parentComponentTransform.GetLocation();
								frameRayToCurrentJoint.Normalize();
								restPoseRayToCurrentJoint.Normalize();

								const FQuat alignmentRotationToApply = FQuat::FindBetween(restPoseRayToCurrentJoint, frameRayToCurrentJoint);
								parentComponentTransform.SetRotation(alignmentRotationToApply * parentComponentTransform.GetRotation());

								// Propagate the rotational change to all siblings on this parent joint that have already been
								// processed.  The pose is processed in hierarchical order, but there is a chance that a
								// sibling (and it's chain) may have been processed prior to this joint.  We can determine
								// if a joint has been processed by comparing it's index against the number of joints in FramePoses.
								for (int iTwistChild : parentJointEntry.childTwistJoints)
								{
									// If we've already processed the child, update it's Frame Transform
									if (iTwistChild < FramePoses.Num())
									{
										FramePoses[iTwistChild].Get<FTransform>() = TargetAdjustedRestPoseData.GetLocalTransform(iTwistChild) * parentComponentTransform;
									}
								}
							}
						}
						jointFrameTransform = retargetedJoint;
					}
				}
			}
			// DO NOT Scale the joints during update, it will affect the child joint calculation from local space in the loop
			FramePoses.Add({ jointEntry.BoneId, jointFrameTransform, jointEntry.componentSpaceScale });
		}
	}

	// Twist Joints
	ProcessFrameInterpolateTwistJoints(FramePoses);

	// Update the hand scale joint scale
	if (InitData.RetargetingMode == EOculusXRBodyRetargetingMode::RotationAndPositions)
	{
		// Rotation and Positions retargeting is the only mode where the hand sizes are changed based on the frame data
		if (SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyLeftHandWrist) && SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyRightHandWrist))
		{
			UpdateScaleForFrame(SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyLeftHandWrist], FramePoses);
			UpdateScaleForFrame(SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyRightHandWrist], FramePoses);
		}
	}

	// Now Apply the FramePoses to the MeshPoses struct
	for (auto& framePoseEntry : FramePoses)
	{
		// Apply Scale here so it won't affect child transforms
		framePoseEntry.Get<FTransform>().SetScale3D(FVector::OneVector * framePoseEntry.Get<float>());
		MeshPoses.SetComponentSpaceTransform(framePoseEntry.Get<FCompactPoseBoneIndex>(), framePoseEntry.Get<FTransform>());
	}

#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	if (DebugDrawMode == EOculusXRBodyDebugDrawMode::FramePose || DebugDrawMode == EOculusXRBodyDebugDrawMode::FramePoseWithMapping)
	{
		const FTransform& MeshTransform = SkeletalMeshComponent->GetComponentTransform();

#if OCULUS_XR_DEBUG_DRAW_MODIFIED_ROOT_MOTION_BEHAVIOR
		if (IsModifiedRootBehavior(InitData.RootMotionBehavior) && BodyState.IsActive)
		{
			FOculusXRRetargetSkeletonEOculusXRBoneID unmodifiedBodyState = Factory::FromOculusXRBodyState(BodyState,
				SourceReferenceInfo.SourceReferenceSkeleton, InitData.TrackingSpaceToComponentSpace, EOculusXRBodyRetargetingRootMotionBehavior::RootFlatTranslationHipRotation);

			DebugDrawUtility.AddSkeleton(unmodifiedBodyState, MeshTransform, FColor::Cyan);
		}
#endif // OCULUS_XR_DEBUG_DRAW_MODIFIED_ROOT_MOTION_BEHAVIOR

		DebugDrawUtility.AddSkeleton(SourceReferenceInfo.LastFrameBodyState, MeshTransform, FColor::Yellow);

		// Calculate the target skeleton for the Frame
		FOculusXRRetargetSkeletonFCompactPoseBoneIndex RetargetedSkeleton = Factory::FromComponentSpaceTransformArray(TargetAdjustedRestPoseData, FramePoses);
		DebugDrawUtility.AddSkeleton(RetargetedSkeleton, MeshTransform, FColor::Green);

		if (DebugDrawMode == EOculusXRBodyDebugDrawMode::FramePoseWithMapping)
		{
			DebugDrawUtility.AddSkeletonMapping(SourceReferenceInfo.LastFrameBodyState,
				RetargetedSkeleton, SourceReferenceInfo.SourceToTargetIdxMap, MeshTransform, FColor::White);
		}
	}
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW

	FCSPose<FCompactPose>::ConvertComponentPosesToLocalPosesSafe(MeshPoses, Output.Pose);
	return true;
}

void FOculusXRAnimNodeBodyRetargeter::ProcessFrameInterpolateTwistJoints(TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const
{
	// Interpolate Twist Joints
	for (const auto& twistJointPair : TargetAdjustedRestPoseData.TwistJoints)
	{
		const TwistJointEntry& twistJoint = twistJointPair.Value;

		const FTransform& twistComponentTransform = FramePoses[twistJoint.TargetTwistJointIdx].Get<FTransform>();
		const FTransform& twistParentComponentTranform = FramePoses[twistJoint.TargetTwistParentJointIdx].Get<FTransform>();
		const FTransform& twistSourceComponentTransform = FramePoses[twistJoint.TargetSourceJointIdx].Get<FTransform>();
		const FTransform& twistSourceParentTransform = FramePoses[twistJoint.TargetSourceParentJointIdx].Get<FTransform>();

		// Put the source joint full joint vector in the same local space to our twist joint
		const FVector FrameParentToSourceRayInTargetLocalSpace = twistParentComponentTranform.GetRotation().Inverse() * (twistSourceComponentTransform.GetLocation() - twistSourceParentTransform.GetLocation());

		// Calculate how much the joint translation has scaled
		const float translationScalar = twistJoint.RestPoseParentToSourceJointLength > 0.0f ? FrameParentToSourceRayInTargetLocalSpace.Length() / twistJoint.RestPoseParentToSourceJointLength : 0.0f;
		const FVector localTranslationToSubtract = (1.0f - translationScalar) * twistJoint.ProjectedSourceJointAlignmentLocalSpace;

		// Put the source joint in local space to our twist joint
		const FTransform twistSourceLocalTransform = twistSourceComponentTransform.GetRelativeTransform(twistComponentTransform);

		const FQuat targetLocalRotation = twistSourceLocalTransform.GetRotation() * twistJoint.TargetSourceLocalRotationOffset;
		const FTransform& twistLocalTransform = TargetAdjustedRestPoseData.GetLocalTransform(twistJoint.TargetTwistJointIdx);

		// Adjust the rotation so it only rotates along the axis of the joint relative to it's parent
		const FVector twistJointReferenceLocalDirection = twistLocalTransform.GetRotation().RotateVector(twistLocalTransform.GetLocation());
		const FVector twistJointTargetLocalDirection = targetLocalRotation.RotateVector(twistLocalTransform.GetLocation());

		// Slerp from our current rotation to our target rotation based on the weight determined during twist joint detection
		const FQuat adjustedTargetLocalRotation =
			FQuat::Slerp(
				twistLocalTransform.GetRotation(),
				FQuat::FindBetween(twistJointTargetLocalDirection, twistJointReferenceLocalDirection) * targetLocalRotation,
				twistJoint.weight);

		// Update our frame pose to reflect the twisted rotation
		FramePoses[twistJoint.TargetTwistJointIdx].Get<FTransform>() = FTransform(adjustedTargetLocalRotation, twistLocalTransform.GetLocation() - localTranslationToSubtract) * twistParentComponentTranform;
	}
}

void FOculusXRAnimNodeBodyRetargeter::UpdateScaleForFrame(const int TargetIndex, TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const
{
	if (TargetIndex != INDEX_NONE)
	{
		TTuple<float, float> targetIndexTotalJointLengths = GetFrameMaxCurrentAndUnModifiedJointLengths(TargetIndex, FramePoses);
		const float Scale = targetIndexTotalJointLengths.Value > 0.0f ? targetIndexTotalJointLengths.Key / targetIndexTotalJointLengths.Value : TargetAdjustedRestPoseData.GlobalComponentSpaceScale;
		UpdateScaleForFrameRecursive(TargetIndex, Scale, FramePoses);
	}
}

void FOculusXRAnimNodeBodyRetargeter::UpdateScaleForFrameRecursive(const int TargetIndex, const float scale, TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const
{
	if (TargetIndex != INDEX_NONE)
	{
		FramePoses[TargetIndex].Get<float>() = scale;
		const TargetSkeletonJointEntry& jointEntry = TargetAdjustedRestPoseData.PoseData[TargetIndex];
		for (int childIdx : jointEntry.childJoints)
		{
			UpdateScaleForFrameRecursive(childIdx, scale, FramePoses);
		}
	}
}

TTuple<float, float> FOculusXRAnimNodeBodyRetargeter::GetFrameMaxCurrentAndUnModifiedJointLengths(int targetJointIndex, const TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses, float currentLength, float unmodifiedLength) const
{
	TTuple<float, float> retVal({ currentLength, unmodifiedLength });
	if (targetJointIndex != INDEX_NONE)
	{
		const TargetSkeletonJointEntry& jointEntry = TargetAdjustedRestPoseData.PoseData[targetJointIndex];
		if (!jointEntry.childJoints.IsEmpty())
		{
			const FVector parentJointPosition = FramePoses[targetJointIndex].Get<FTransform>().GetLocation();
			for (int childIdx : jointEntry.childJoints)
			{
				const TargetSkeletonJointEntry& childJointEntry = TargetAdjustedRestPoseData.PoseData[childIdx];
				const float childUnmodifiedLength = childJointEntry.unmodifiedJointLength;
				const float childCurrentLength = (FramePoses[childIdx].Get<FTransform>().GetLocation() - parentJointPosition).Length();

				TTuple<float, float> childLengths = GetFrameMaxCurrentAndUnModifiedJointLengths(childIdx, FramePoses, currentLength + childCurrentLength, unmodifiedLength + childUnmodifiedLength);
				if (childLengths.Key > retVal.Key)
				{
					retVal = childLengths;
				}
			}
		}
	}

	return retVal;
}

bool FOculusXRAnimNodeBodyRetargeter::RetargetFromBodyState(
	const FOculusXRBodyState& BodyState,
	const USkeletalMeshComponent* SkeletalMeshComponent,
	const float WorldScale,
	FPoseContext& Output)
{
	if (SkeletalMeshComponent && UpdateSkeleton(BodyState, Output.Pose.GetBoneContainer(), SkeletalMeshComponent, WorldScale))
	{
		return ProcessFrameRetargeting(BodyState, SkeletalMeshComponent, Output);
	}
	return false;
}

void FOculusXRAnimNodeBodyRetargeter::SetTargetToTPose()
{
	TMap<int, TArray<int>> AncestorToChildTPoseAlignmentMap;
	TSet<int> MappedAdjustableJointsWithNoAdjustableChildren;
	TSet<int> SpecialCaseRotationBehaviorAncestors;

	// Iterate the newly generated list and generate the Child Joint Arrays
	for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
	{
		if (TargetAdjustedRestPoseData.GetParentBoneIndex(i) != INDEX_NONE && TargetAdjustedRestPoseData.GetMappedAncestorIndex(i) != INDEX_NONE && kTPOSE_ADJUSTABLE_JOINT_SET.Contains(TargetAdjustedRestPoseData.GetSourceJointID(i)))
		{
			int TargetMappedAncestorIndex = TargetAdjustedRestPoseData.GetMappedAncestorIndex(i);
			const EOculusXRBoneID sourceJointID = TargetAdjustedRestPoseData.GetSourceJointID(i);
			int SourceJointIdx = SourceReferenceInfo.SourceSkeleton.GetBoneIndex(sourceJointID);
			int SourceAncestorIdx = SourceReferenceInfo.SourceSkeleton.GetBoneIndex(
				TargetAdjustedRestPoseData.GetSourceJointID(TargetMappedAncestorIndex));
			if (SourceJointIdx != INDEX_NONE)
			{
				if (SourceAncestorIdx != INDEX_NONE)
				{
					if (kTPOSE_SPECIAL_HANDLING_ADJUSTABLE_HAND_JOINTS.Contains(sourceJointID) && TargetAdjustedRestPoseData.GetChildJointCount(TargetMappedAncestorIndex) == 1)
					{
						// Hack - this is specific for proximital finger joints
						// it only works for these finger joints with a single child.
						// Just skip if we have a non-conforming target skeleton
						SpecialCaseRotationBehaviorAncestors.Add(TargetMappedAncestorIndex);
					}
					if (AncestorToChildTPoseAlignmentMap.Contains(TargetMappedAncestorIndex))
					{
						AncestorToChildTPoseAlignmentMap[TargetMappedAncestorIndex].Add(i);
					}
					else
					{
						AncestorToChildTPoseAlignmentMap.Add(TargetMappedAncestorIndex, { i });
					}
				}

				// Special case to catch the finger tips - Check if the joint has any mapped children
				if (TargetAdjustedRestPoseData.IsValidIndex(TargetAdjustedRestPoseData.GetParentBoneIndex(i)) && TargetAdjustedRestPoseData.FindNextChildJointMappedToSource(i) == INDEX_NONE)
				{
					MappedAdjustableJointsWithNoAdjustableChildren.Add(i);
				}
			}
		}
	}

	// Set Joints to T-Pose using the TargetAdjustedRestPoseData.PoseData Map we generated
	for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
	{
		if (!AncestorToChildTPoseAlignmentMap.Contains(i) && !MappedAdjustableJointsWithNoAdjustableChildren.Contains(i))
		{
			continue;
		}

		FTransform& TargetJointTransform = TargetAdjustedRestPoseData.PoseData[i].ComponentTransform;

		if (AncestorToChildTPoseAlignmentMap.Contains(i))
		{
			if (SpecialCaseRotationBehaviorAncestors.Contains(i))
			{
				// TODO: For now, just skip these joints - revisit to see if we
				// can get better alignment of the hands
				continue;
			}
			const EOculusXRBoneID sourceJointID = TargetAdjustedRestPoseData.GetSourceJointID(i);
			int SourceJointIdx = SourceReferenceInfo.SourceSkeleton.GetBoneIndex(TargetAdjustedRestPoseData.GetSourceJointID(i));

			const FTransform& SourceJointTransform = SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceJointIdx);

			FVector sourceAlignment = FVector::ZeroVector;
			FVector targetAlignment = FVector::ZeroVector;

			FVector sourceTwistAlignment = FVector::ZeroVector;
			FVector targetTwistAlignment = FVector::ZeroVector;

			FVector lastSourceChildLocation = FVector::ZeroVector;
			FVector lastTargetChildLocation = FVector::ZeroVector;

			const TArray<int>& AncestorChildIndexArray = AncestorToChildTPoseAlignmentMap[i];
			for (int iChild = 0; iChild < AncestorChildIndexArray.Num(); iChild++)
			{
				const int TargetChildIdx = AncestorChildIndexArray[iChild];
				int SourceChildIdx = SourceReferenceInfo.SourceSkeleton.GetBoneIndex(TargetAdjustedRestPoseData.GetSourceJointID(TargetChildIdx));
				check(SourceJointIdx != INDEX_NONE && SourceChildIdx != INDEX_NONE);

				const FTransform& SourceChildTransform = SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceChildIdx);
				const FTransform& TargetChildTransform = TargetAdjustedRestPoseData.GetComponentTransform(TargetChildIdx);

				if (iChild > 0)
				{
					sourceTwistAlignment = sourceTwistAlignment + (SourceChildTransform.GetLocation() - lastSourceChildLocation);
					targetTwistAlignment = targetTwistAlignment + (TargetChildTransform.GetLocation() - lastTargetChildLocation);
				}

				sourceAlignment = sourceAlignment + (SourceChildTransform.GetLocation() - SourceJointTransform.GetLocation());
				targetAlignment = targetAlignment + (TargetChildTransform.GetLocation() - TargetJointTransform.GetLocation());

				lastSourceChildLocation = SourceChildTransform.GetLocation();
				lastTargetChildLocation = TargetChildTransform.GetLocation();
			}

			// If we have more than one child, twist to align more with the source as calculated
			// Note - this is primarily for wrist joints.
			if (AncestorChildIndexArray.Num() > 0)
			{
				FQuat TwistRotationToApply = FQuat::FindBetween(targetTwistAlignment, sourceTwistAlignment);

				FQuat TargetTwistAdjustedRotation = TwistRotationToApply * TargetJointTransform.GetRotation();
				TargetTwistAdjustedRotation.Normalize();
				TargetJointTransform.SetRotation(TargetTwistAdjustedRotation);
			}

			FQuat RotationToApply = FQuat::FindBetween(targetAlignment, sourceAlignment);

			// Rotate the Target by the Delta
			FQuat TargetNewRotation = RotationToApply * TargetJointTransform.GetRotation();
			TargetNewRotation.Normalize();
			TargetJointTransform.SetRotation(TargetNewRotation);
		}
		else
		{
			// This is a terminating mapped joint (like a finger tip, etc)
			// Use it's parent joint as it's rotation (resolves mappings where the finger tip doesn't have a non-rendering joint)
			check(MappedAdjustableJointsWithNoAdjustableChildren.Contains(i));
			TargetJointTransform.SetRotation(TargetAdjustedRestPoseData.GetComponentTransform(TargetAdjustedRestPoseData.GetParentBoneIndex(i)).GetRotation());
		}

		// Update the Local Transform
		const int ParentIdx = TargetAdjustedRestPoseData.GetParentBoneIndex(i);
		if (ParentIdx == INDEX_NONE)
		{
			TargetAdjustedRestPoseData.PoseData[i].LocalTransform = TargetJointTransform;
			TargetAdjustedRestPoseData.PoseData[i].ComponentTransform = TargetJointTransform;
		}
		else
		{
			TargetAdjustedRestPoseData.PoseData[i].LocalTransform =
				TargetJointTransform.GetRelativeTransform(TargetAdjustedRestPoseData.GetComponentTransform(ParentIdx));
		}

		// Update all the children from the Ancestor after we've made the adjustment
		UpdateAllChildrenComponentFromLocalRecursive(TargetAdjustedRestPoseData.PoseData, ParentIdx != INDEX_NONE ? ParentIdx : i);
	}
}

// Captures unmapped joints that have mapped joints on both ends of the chain.
// Retargeter will treat as twist joints to interpolate motion (ie - unmapped spine joints, etc)
// If the chain ends with no terminating child mapping, it will be skipped.
// Chains terminate at joints with multiple children, if this joint is unmapped, the chain will be skipped.
void FOculusXRAnimNodeBodyRetargeter::CaptureUnmappedJointChainRecursive(const TArray<TargetSkeletonJointEntry>& jointData, const int jointIdx, TArray<int>& outLinkArray)
{
	outLinkArray.Add(jointIdx);
	const TargetSkeletonJointEntry& jointEntry = jointData[jointIdx];
	for (int childJointIdx : jointEntry.childJoints)
	{
		if (jointData[childJointIdx].sourceJointID != EOculusXRBoneID::None)
		{
			// We've found our terminating joint for the chain
			outLinkArray.Add(childJointIdx);
			return;
		}
	}
	// We didn't find a terminating joint, if we only have a single child joint
	// recursively generate the joint chain.
	if (jointEntry.childJoints.Num() == 1)
	{
		CaptureUnmappedJointChainRecursive(jointData, jointEntry.childJoints[0], outLinkArray);
	}
}

void FOculusXRAnimNodeBodyRetargeter::CacheTwistJoints()
{
	check(!TargetAdjustedRestPoseData.IsEmpty());
	TargetAdjustedRestPoseData.TwistJoints.Empty();

	for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
	{
		if (TargetAdjustedRestPoseData.IsJointMappedToSource(i))
		{
			// First, look for unmapped joints in a chain between two mapped joints
			TArray<int> jointLinkArray;
			CaptureUnmappedJointChainRecursive(TargetAdjustedRestPoseData.PoseData, i, jointLinkArray);

			if (jointLinkArray.Num() > 2 && TargetAdjustedRestPoseData.IsJointMappedToSource(jointLinkArray.Last()))
			{
				// Now Add the joints (Skip the first and Last Array entries as they are mapped joints)
				const int chainTerminatingJointIdx = jointLinkArray.Last();
				const FTransform& chainTerminatingJointComponentTransform = TargetAdjustedRestPoseData.GetComponentTransform(chainTerminatingJointIdx);
				const FTransform& chainStartJointComponentTransform = TargetAdjustedRestPoseData.GetComponentTransform(jointLinkArray[0]);
				const FVector chainComponentRay = chainTerminatingJointComponentTransform.GetLocation() - chainStartJointComponentTransform.GetLocation();
				const float chainRayLength = chainComponentRay.Length();
				for (int iChainIdx = 1; iChainIdx < jointLinkArray.Num() - 1; ++iChainIdx)
				{
					const int linkJointIdx = jointLinkArray[iChainIdx];
					const TargetSkeletonJointEntry& linkJointEntry = TargetAdjustedRestPoseData.PoseData[linkJointIdx];
					const FTransform& linkComponentTransform = linkJointEntry.ComponentTransform;

					// Calculate the weight by projecting our joint to the ray between the start of the chain and the end
					const FVector linkComponentRay = linkComponentTransform.GetLocation() - chainStartJointComponentTransform.GetLocation();
					const float linkProjectionLengthFromStartJoint = linkComponentRay.Dot(chainComponentRay) / chainRayLength;
					const float weight = linkProjectionLengthFromStartJoint / chainRayLength;

					// Convert this ray to the same space as the chainJoint Transform using the parent joint
					const FVector projectedRayToTerminatingJointLocalSpace = TargetAdjustedRestPoseData.GetComponentTransform(linkJointEntry.ParentIdx).GetRotation().Inverse() * chainComponentRay * weight;

					TargetAdjustedRestPoseData.TwistJoints.Emplace(linkJointIdx, { chainTerminatingJointIdx, linkJointIdx, linkJointEntry.ParentIdx, jointLinkArray[0], chainTerminatingJointComponentTransform.GetRelativeTransform(linkComponentTransform).GetRotation(), projectedRayToTerminatingJointLocalSpace, chainRayLength, linkProjectionLengthFromStartJoint, weight, false });
				}
			}

			// Now look for Twist Joints
			TargetSkeletonJointEntry& parentJointEntry = TargetAdjustedRestPoseData.PoseData[i];
			if (parentJointEntry.childJoints.Num() > 1)
			{
				// Twist joints should all share the same common parent.
				// They should have a mapped sibling and be in line with the sibling relative to the parent
				TArray<int> possibleTwistJoints;
				TArray<int> possibleTerminatingJoints;

				for (int childJointIdx : parentJointEntry.childJoints)
				{
					if (TargetAdjustedRestPoseData.IsJointMappedToSource(childJointIdx))
					{
						// Joints that are mapped may possibly drive a twist joint
						possibleTerminatingJoints.Add(childJointIdx);
					}
					else
					{
						// This might be a twist joint, will validate below
						possibleTwistJoints.Add(childJointIdx);
					}
				}

				// If we have possible twist joints and possible terminating joints, iterate the list
				if (!possibleTwistJoints.IsEmpty() && !possibleTerminatingJoints.IsEmpty())
				{
					for (int twistJointIdx : possibleTwistJoints)
					{
						for (int terminatingJointIdx : possibleTerminatingJoints)
						{
							const FVector rayToTerminatingJoint = TargetAdjustedRestPoseData.GetLocalTransform(terminatingJointIdx).GetLocation();
							const float distanceToTerminatingJoint = rayToTerminatingJoint.Length();
							const FVector rayToTwistJoint = TargetAdjustedRestPoseData.GetLocalTransform(twistJointIdx).GetLocation();
							const float distanceToTwistJoint = rayToTwistJoint.Length();
							const float twistRayToTerminatingDot = rayToTwistJoint.Dot(rayToTerminatingJoint);
							const float twistProjectionLength = twistRayToTerminatingDot / distanceToTerminatingJoint;
							const float weight = twistProjectionLength / distanceToTerminatingJoint;

							// Twist Joint should always be closer to the parent than the terminating joint
							if (weight <= 1.0f)
							{
								// Check the angle between the rays
								const float angleCheck = FMath::Acos(twistRayToTerminatingDot / (rayToTwistJoint.Length() * distanceToTerminatingJoint));
								// Rotateable joints are within 2 degrees of the ray between the parent and the terminating joint
								const bool isRotateableJoint = angleCheck <= kTWIST_JOINT_MIN_ANGLE_THRESHOLD;
								const bool MapContainsTwistJoint = TargetAdjustedRestPoseData.TwistJoints.Contains(twistJointIdx);
								// For the Rare Case that we have a rig with two possible terminating joints and this joint
								// is "rotateable" ie. in line with the joint, overwrite the record for this twist joint
								if (isRotateableJoint || !MapContainsTwistJoint)
								{
									const FTransform terminatiingJointLocalToTwistJoint =
										TargetAdjustedRestPoseData.GetComponentTransform(terminatingJointIdx).GetRelativeTransform(TargetAdjustedRestPoseData.GetComponentTransform(twistJointIdx));

									// Avoid double additions if we're in the rare case
									// of overwriting the non-rotateable record.
									if (!MapContainsTwistJoint)
									{
										parentJointEntry.childTwistJoints.Add(twistJointIdx);
									}
									// We've located a twist joint (NOTE: Emplace should overwrite if the key already exists)
									TargetAdjustedRestPoseData.TwistJoints.Emplace(twistJointIdx, { terminatingJointIdx, twistJointIdx, i, i, terminatiingJointLocalToTwistJoint.GetRotation().Inverse(), rayToTerminatingJoint * weight, distanceToTerminatingJoint, twistProjectionLength, weight, isRotateableJoint });
								}
							}
						}
					}
				}
			}
		}
	}
}

void FOculusXRAnimNodeBodyRetargeter::ApplyScaleAndProportion()
{
	// Reset Global Component Scale
	TargetAdjustedRestPoseData.GlobalComponentSpaceScale = 1.0f;

	if (InitData.RetargetingMode != EOculusXRBodyRetargetingMode::RotationOnlyNoScaling)
	{
		// Use the Right Wrist for Alignment
		const EOculusXRBoneID rightWristJoint = EOculusXRBoneID::BodyRightHandWrist;
		const EOculusXRBoneID leftWristJoint = EOculusXRBoneID::BodyLeftHandWrist;

		if (SourceReferenceInfo.SourceToTargetIdxMap.Contains(rightWristJoint) && SourceReferenceInfo.SourceSkeleton.IsValid(rightWristJoint) && SourceReferenceInfo.SourceToTargetIdxMap.Contains(leftWristJoint) && SourceReferenceInfo.SourceSkeleton.IsValid(leftWristJoint))

		{
			const TargetSkeletonJointEntry& rightWristTargetJoint =
				TargetAdjustedRestPoseData.PoseData[SourceReferenceInfo.SourceToTargetIdxMap[rightWristJoint]];
			check(rightWristTargetJoint.sourceJointID == rightWristJoint);
			const FTransform& SourceRightWrist = SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceReferenceInfo.SourceSkeleton.GetBoneIndex(rightWristJoint));
			const FTransform& TargetRightWrist = TargetAdjustedRestPoseData.GetComponentTransform(SourceReferenceInfo.SourceToTargetIdxMap[rightWristJoint]);
			const FTransform& TargetLeftWrist = TargetAdjustedRestPoseData.GetComponentTransform(SourceReferenceInfo.SourceToTargetIdxMap[leftWristJoint]);

			const FVector ForwardDirection = InitData.TargetFacingTransform.GetRotation().GetAxisX();
			const FVector RightDirection = InitData.TargetFacingTransform.GetRotation().GetAxisY();
			const FVector UpDirection = InitData.TargetFacingTransform.GetRotation().GetAxisZ();

			const float TargetWristHeight = (TargetRightWrist.GetLocation() * UpDirection).Length();
			TargetAdjustedRestPoseData.GlobalComponentSpaceScale = (SourceRightWrist.GetLocation() * UpDirection).Length() / (TargetWristHeight > 0.0f ? TargetWristHeight : 1.0f);

			// Scale the entire character based on the ratio for the height
			for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
			{
				TargetAdjustedRestPoseData.PoseData[i].ComponentTransform.SetLocation(
					TargetAdjustedRestPoseData.GetComponentTransform(i).GetLocation() * TargetAdjustedRestPoseData.GlobalComponentSpaceScale);
			}

			// Shift the entire Model against the Forward Vector to align the Wrists
			const FVector Offset =
				(SourceRightWrist.GetLocation() - rightWristTargetJoint.ComponentTransform.GetLocation()) * FVector(FMath::Abs(ForwardDirection.X), FMath::Abs(ForwardDirection.Y), FMath::Abs(ForwardDirection.Z));

			for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
			{
				FVector NewLocation = TargetAdjustedRestPoseData.GetComponentTransform(i).GetLocation() + Offset;
				TargetAdjustedRestPoseData.PoseData[i].ComponentTransform.SetLocation(NewLocation);
			}

			// Now Scale the Arms Towards the Body to Align the Wrists
			const EOculusXRBoneID rightShoulderJoint = EOculusXRBoneID::BodyRightShoulder;
			const EOculusXRBoneID leftShoulderJoint = EOculusXRBoneID::BodyLeftShoulder;

			if (
				IsRotationAndPositionRetargetingMode(InitData.RetargetingMode) && SourceReferenceInfo.SourceToTargetIdxMap.Contains(rightShoulderJoint) && SourceReferenceInfo.SourceSkeleton.IsValid(rightShoulderJoint) && SourceReferenceInfo.SourceToTargetIdxMap.Contains(leftShoulderJoint) && SourceReferenceInfo.SourceSkeleton.IsValid(leftShoulderJoint))

			{
				// Right Arm
				const float sourceRightWristAbsValue = (SourceRightWrist.GetLocation() * RightDirection).Length();
				const float targetRightWristAbsValue = (TargetRightWrist.GetLocation() * RightDirection).Length();
				const float RightArmScaleRatio = sourceRightWristAbsValue / (targetRightWristAbsValue > 0.0f ? targetRightWristAbsValue : 1.0f);
				const FVector rightArmScalar(RightArmScaleRatio, 1.0f, 1.0f);

				// Left Arm
				const FTransform& SourceLeftWrist = SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceReferenceInfo.SourceSkeleton.GetBoneIndex(leftWristJoint));

				const float sourceLeftWristAbsValue = (SourceLeftWrist.GetLocation() * RightDirection).Length();
				const float targetLeftWristAbsValue = (TargetLeftWrist.GetLocation() * RightDirection).Length();
				const float LeftArmScaleRatio = sourceLeftWristAbsValue / (targetLeftWristAbsValue > 0.0f ? targetLeftWristAbsValue : 1.0f);
				const FVector leftArmScalar(LeftArmScaleRatio, 1.0f, 1.0f);

				// Scale the Right Arm
				ScaleAllChildrenComponentSpaceRecursive(TargetAdjustedRestPoseData.PoseData, SourceReferenceInfo.SourceToTargetIdxMap[rightShoulderJoint], rightArmScalar);

				// Scale the Left Arm
				ScaleAllChildrenComponentSpaceRecursive(TargetAdjustedRestPoseData.PoseData, SourceReferenceInfo.SourceToTargetIdxMap[leftShoulderJoint], leftArmScalar);

				// Last Scale/Align the Fingers
				if (InitData.RetargetingMode == EOculusXRBodyRetargetingMode::RotationAndPositions)
				{
					// TODO: Improve this Alignment code to better respect the target rig hand proportions

					// NOTE: Assumption is that order of Array is from Parent -> Child
					TSet<int> AdjustedParentJoints;
					AdjustedParentJoints.Reserve(kALIGNABLE_HAND_JOINTS.Num());
					for (EOculusXRBoneID fingerSourceJoint : kALIGNABLE_HAND_JOINTS)
					{
						if (SourceReferenceInfo.SourceToTargetIdxMap.Contains(fingerSourceJoint) && SourceReferenceInfo.SourceSkeleton.IsValid(fingerSourceJoint))
						{
							const FTransform& SourceFingerTransform =
								SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceReferenceInfo.SourceSkeleton.GetBoneIndex(fingerSourceJoint));
							const int fingerIndex = SourceReferenceInfo.SourceToTargetIdxMap[fingerSourceJoint];
							TargetSkeletonJointEntry& fingerToAdjust = TargetAdjustedRestPoseData.PoseData[fingerIndex];
							check(fingerToAdjust.sourceJointID == fingerSourceJoint);

							// Fingers should always have a parent joint - check added, but also protected in case someone maps
							// incorrectly
							check(fingerToAdjust.ParentIdx != INDEX_NONE);
							if (fingerToAdjust.ParentIdx != INDEX_NONE)
							{
								TargetSkeletonJointEntry& fingerParentJoint = TargetAdjustedRestPoseData.PoseData[fingerToAdjust.ParentIdx];

								// We only want to rotate a parent joint once
								if (!AdjustedParentJoints.Contains(fingerToAdjust.ParentIdx))
								{
									// Add the index so we won't rotate it again
									AdjustedParentJoints.Add(fingerToAdjust.ParentIdx);

									// Only Rotate the parent if we are the first child
									const FVector currentRayToJoint = fingerToAdjust.ComponentTransform.GetLocation() - fingerParentJoint.ComponentTransform.GetLocation();
									const FVector targetRayToJoint = SourceFingerTransform.GetLocation() - fingerParentJoint.ComponentTransform.GetLocation();

									// Update our Joint's local location length
									FVector fingerCurrentLocalOffset = fingerToAdjust.LocalTransform.GetLocation();
									fingerCurrentLocalOffset.Normalize();
									fingerToAdjust.LocalTransform.SetLocation(fingerCurrentLocalOffset * targetRayToJoint.Length());

									// Apply the rotation to our parent
									const FQuat ParentRotationToApply = FQuat::FindBetween(currentRayToJoint, targetRayToJoint);
									FQuat NewParentComponentRotation = ParentRotationToApply * fingerParentJoint.ComponentTransform.GetRotation();
									NewParentComponentRotation.Normalize();
									fingerParentJoint.ComponentTransform.SetRotation(NewParentComponentRotation);
									if (fingerParentJoint.ParentIdx == INDEX_NONE)
									{
										fingerParentJoint.LocalTransform = fingerParentJoint.ComponentTransform;
									}
									else
									{
										fingerParentJoint.LocalTransform = fingerParentJoint.ComponentTransform.GetRelativeTransform(
											TargetAdjustedRestPoseData.GetComponentTransform(fingerParentJoint.ParentIdx));
									}
									UpdateAllChildrenComponentFromLocalRecursive(TargetAdjustedRestPoseData.PoseData, fingerToAdjust.ParentIdx);
								}
								else
								{
									// Update our position, the update the hierarchy
									fingerToAdjust.ComponentTransform.SetLocation(SourceFingerTransform.GetLocation());
									fingerToAdjust.LocalTransform = fingerToAdjust.ComponentTransform.GetRelativeTransform(fingerParentJoint.ComponentTransform);
									UpdateAllChildrenComponentFromLocalRecursive(TargetAdjustedRestPoseData.PoseData, fingerIndex);
								}
							}
						}
					}
				}
			}

			// Update the Local Transforms
			for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
			{
				const int ParentIdx = TargetAdjustedRestPoseData.GetParentBoneIndex(i);
				if (ParentIdx == INDEX_NONE)
				{
					TargetAdjustedRestPoseData.PoseData[i].LocalTransform = TargetAdjustedRestPoseData.GetComponentTransform(i);
				}
				else
				{
					TargetAdjustedRestPoseData.PoseData[i].LocalTransform =
						TargetAdjustedRestPoseData.GetComponentTransform(i).GetRelativeTransform(TargetAdjustedRestPoseData.GetComponentTransform(ParentIdx));
				}
			}
		}
	}
}

void FOculusXRAnimNodeBodyRetargeter::InitializeScaleAndOffsetData()
{
	// Scale and unmodified joint length are calculated and stored.
	// This will require some testing - scale may need to be applied to the parent joint,
	// not the child joint.  This data should be accessible from the parent using the
	// child joint array stored in each joint record.

	// Calculate Hand Scale
	const int RightWristBoneIndex = SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyRightHandWrist) ? SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyRightHandWrist] : INDEX_NONE;
	const int LeftWristBoneIndex = SourceReferenceInfo.SourceToTargetIdxMap.Contains(EOculusXRBoneID::BodyLeftHandWrist) ? SourceReferenceInfo.SourceToTargetIdxMap[EOculusXRBoneID::BodyLeftHandWrist] : INDEX_NONE;

	const TTuple<float, float> RightHandLengths = GetMaxCurrentAndUnModifiedJointLengths(RightWristBoneIndex);
	const TTuple<float, float> LeftHandLengths = GetMaxCurrentAndUnModifiedJointLengths(LeftWristBoneIndex);

	const float RightHandScale = RightHandLengths.Value > 0.0f ? RightHandLengths.Key / RightHandLengths.Value : TargetAdjustedRestPoseData.GlobalComponentSpaceScale;
	const float LeftHandScale = LeftHandLengths.Value > 0.0f ? LeftHandLengths.Key / LeftHandLengths.Value : TargetAdjustedRestPoseData.GlobalComponentSpaceScale;

	for (int i = 0; i < TargetAdjustedRestPoseData.GetNumBones(); ++i)
	{
		TargetSkeletonJointEntry& jointEntry = TargetAdjustedRestPoseData.PoseData[i];
		jointEntry.componentSpaceScale = TargetAdjustedRestPoseData.GlobalComponentSpaceScale;

		// If this is a wrist or Hand, scale to the hand scale
		if (i == RightWristBoneIndex || TargetAdjustedRestPoseData.IsAncestorToBoneIndex(RightWristBoneIndex, i))
		{
			jointEntry.componentSpaceScale = RightHandScale;
		}
		else if (i == LeftWristBoneIndex || TargetAdjustedRestPoseData.IsAncestorToBoneIndex(LeftWristBoneIndex, i))
		{
			jointEntry.componentSpaceScale = LeftHandScale;
		}
		else if (!IsHipOrRootSourceJoint(jointEntry.sourceJointID) && !jointEntry.childJoints.IsEmpty())
		{
			float totalUnmodifiedJointLength = 0.0f;
			float totalCurrentJointLength = 0.0f;
			for (int childJointIdx : jointEntry.childJoints)
			{
				const TargetSkeletonJointEntry& childJointEntry = TargetAdjustedRestPoseData.PoseData[childJointIdx];
				totalUnmodifiedJointLength += childJointEntry.unmodifiedJointLength;
				totalCurrentJointLength += childJointEntry.LocalTransform.GetLocation().Length();
			}

			if (totalUnmodifiedJointLength > 0.0f)
			{
				jointEntry.componentSpaceScale = totalCurrentJointLength / totalUnmodifiedJointLength;
			}
		}

		if (TargetAdjustedRestPoseData.IsJointMappedToSource(i))
		{
			int SourceJointIdx = SourceReferenceInfo.SourceSkeleton.GetBoneIndex(TargetAdjustedRestPoseData.GetSourceJointID(i));
			if (SourceJointIdx != INDEX_NONE)
			{
				const FTransform& SourceJoint = SourceReferenceInfo.SourceSkeleton.GetComponentTransform(SourceJointIdx);
				const FTransform& TargetJoint = TargetAdjustedRestPoseData.GetComponentTransform(i);

				const FQuat SourceJointInvRot = SourceJoint.GetRotation().Inverse();
				const FQuat sourceToTargetRotation = SourceJointInvRot * TargetJoint.GetRotation();
				FVector sourceToTargetOffset = SourceJointInvRot * (TargetJoint.GetLocation() - SourceJoint.GetLocation());

				jointEntry.sourceJointLocalOffset = FTransform(sourceToTargetRotation, sourceToTargetOffset);
			}
		}
	}
}

TTuple<float, float> FOculusXRAnimNodeBodyRetargeter::GetMaxCurrentAndUnModifiedJointLengths(int targetJointIndex, float currentLength, float unmodifiedLength) const
{
	TTuple<float, float> retVal({ currentLength, unmodifiedLength });
	if (targetJointIndex != INDEX_NONE)
	{
		const TargetSkeletonJointEntry& jointEntry = TargetAdjustedRestPoseData.PoseData[targetJointIndex];
		if (!jointEntry.childJoints.IsEmpty())
		{
			for (int childIdx : jointEntry.childJoints)
			{
				const TargetSkeletonJointEntry& childJointEntry = TargetAdjustedRestPoseData.PoseData[childIdx];
				const float childUnmodifiedLength = childJointEntry.unmodifiedJointLength;
				const float childCurrentLength = childJointEntry.LocalTransform.GetLocation().Length();

				TTuple<float, float> childLengths = GetMaxCurrentAndUnModifiedJointLengths(childIdx, currentLength + childCurrentLength, unmodifiedLength + childUnmodifiedLength);
				if (childLengths.Key > retVal.Key)
				{
					retVal = childLengths;
				}
			}
		}
	}

	return retVal;
}

void FOculusXRAnimNodeBodyRetargeter::UpdateAllChildrenComponentFromLocalRecursive(TArray<TargetSkeletonJointEntry>& jointData, const int rootJointIdx)
{
	for (int childJointIdx : jointData[rootJointIdx].childJoints)
	{
		jointData[childJointIdx].ComponentTransform = jointData[childJointIdx].LocalTransform * jointData[rootJointIdx].ComponentTransform;
		UpdateAllChildrenComponentFromLocalRecursive(jointData, childJointIdx);
	}
}

void FOculusXRAnimNodeBodyRetargeter::ScaleAllChildrenComponentSpaceRecursive(TArray<TargetSkeletonJointEntry>& jointData, const int rootJointIdx, const FVector& scalar)
{
	for (int childJointIdx : jointData[rootJointIdx].childJoints)
	{
		// Scale the Child Joint
		jointData[childJointIdx].ComponentTransform.SetLocation(jointData[childJointIdx].ComponentTransform.GetLocation() * scalar);
		// Recurse through the children
		ScaleAllChildrenComponentSpaceRecursive(jointData, childJointIdx, scalar);
	}
}

/**
 * Identify the parents of bones in the SkeletonMesh that are part of the bone map.
 *
 * The Ancestor should reflect the hierarchy of the source skeleton in the case that
 * a sibling or child joint was mapped out of hierarchy order to the target skeleton.
 */
void FOculusXRAnimNodeBodyRetargeter::CalculateMappedAncestorValues(const SourceInfo& SourceReferenceInfo, const int CurrentMappedAncestorIdx, const int JointIdx, TargetSkeletonPoseData& TargetSkeleton)
{
	if (JointIdx != INDEX_NONE)
	{
		TargetSkeletonJointEntry& jointEntry = TargetSkeleton.PoseData[JointIdx];

		// The structure should be initialized so that all ancestors are marked to none.
		check(jointEntry.mappedAncestorIdx == INDEX_NONE);

		int nextMappedIndex = CurrentMappedAncestorIdx;

		// If this is a mapped joint, we need to update the nextMapped index and ensure that our
		// mapped ancesstor is relative to the child joint the source skeleton.
		// This is to allow for alignment of target skeletons that are in a different hierarchical order than the source skeleton.
		// (Example: The tracking skeleton is elbow -> Wrist and WristTwist as children/siblings to each other, some target skeletons
		// are mapped as elbow -> WristTwist -> Wrist.  This complicates alignment code without using the source skeleton hierarchy as
		// the reference).
		if (jointEntry.sourceJointID != EOculusXRBoneID::None)
		{
			nextMappedIndex = JointIdx;

			// Walk up the source skeleton parenting to find the next mapped joint.  We can't trust that the CurrentMappedAncestorIdx is actually correct for this mapped joint.
			EOculusXRBoneID sourceParentJoint = SourceReferenceInfo.SourceSkeleton.GetParentBoneId(jointEntry.sourceJointID);
			while (sourceParentJoint != EOculusXRBoneID::None)
			{
				// Found a possible match - check if the joint is an actual ancestor to our current joint (in the target skeleton)
				if (SourceReferenceInfo.SourceToTargetIdxMap.Contains(sourceParentJoint) && TargetSkeleton.IsAncestorToBoneIndex(SourceReferenceInfo.SourceToTargetIdxMap[sourceParentJoint], JointIdx))
				{
					jointEntry.mappedAncestorIdx = SourceReferenceInfo.SourceToTargetIdxMap[sourceParentJoint];
					break;
				}
				sourceParentJoint = SourceReferenceInfo.SourceSkeleton.GetParentBoneId(sourceParentJoint);
			}
		}
		else
		{
			// In the case that this joint is unmapped, we use the current tracked ancestor index.
			// It's the last joint we found that was mapped.  This is a recursive function, so that value is passed
			// in as a parameter.
			jointEntry.mappedAncestorIdx = CurrentMappedAncestorIdx;
		}

		// Recursively iterate down the child joints
		for (int childJointIdx : jointEntry.childJoints)
		{
			CalculateMappedAncestorValues(SourceReferenceInfo, nextMappedIndex, childJointIdx, TargetSkeleton);
		}
	}
}

/**
 * This gets called when the bone container changes and we have to remap the bones in case the skeleton has changed.
 * @param BoneContainer
 */
TMap<FCompactPoseBoneIndex, EOculusXRBoneID> FOculusXRAnimNodeBodyRetargeter::RecalculateMapping(
	const FBoneContainer& BoneContainer, const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap)
{
	TMap<FCompactPoseBoneIndex, EOculusXRBoneID> TargetToSourceMap;
	if (SourceToTargetNameMap && !SourceToTargetNameMap->IsEmpty())
	{
		// Iterate through all possible bones in Source Skeleton and map them to the Target Skeleton
		// according to what the user has input in the retargeting asset
		for (uint8 SourceBoneId = 0; SourceBoneId < static_cast<uint8>(EOculusXRBoneID::COUNT); ++SourceBoneId)
		{
			const auto TargetBoneName = SourceToTargetNameMap->Find(static_cast<EOculusXRBoneID>(SourceBoneId));
			if (!TargetBoneName || TargetBoneName->IsNone())
			{
				// Skip the entry in the loop if the bone is not mapped
				continue;
			}
			// Check if the bone name exists in the current skeleton
			if (const int32 TargetBoneIndex = BoneContainer.GetPoseBoneIndexForBoneName(*TargetBoneName); TargetBoneIndex != INDEX_NONE)
			{
				auto TargetBoneId = BoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(TargetBoneIndex));
				if (TargetBoneId == INDEX_NONE)
				{
					UE_LOG(LogOculusXRRetargeting, Warning,
						TEXT("Bone %s was intentionally mapped to %s. But this target doesn't exist in skeleton."),
						*StaticEnum<EOculusXRBoneID>()->GetValueAsString(static_cast<EOculusXRBoneID>(SourceBoneId)),
						*TargetBoneName->ToString());
					continue;
				}
				TargetToSourceMap.Add(TargetBoneId, static_cast<EOculusXRBoneID>(SourceBoneId));
			}
		}

		// Iterate through all possible bones in Target Skeleton and add them to the TargetToSourceMap if they are not already present
		for (int32 TargetBoneIndex = 0; TargetBoneIndex < BoneContainer.GetNumBones(); ++TargetBoneIndex)
		{
			if (auto TargetBoneId = BoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(TargetBoneIndex)); !TargetToSourceMap.Contains(TargetBoneId))
			{
				TargetToSourceMap.Add(TargetBoneId, EOculusXRBoneID::None);
			}
		}
	}

	return TargetToSourceMap;
}

void FOculusXRAnimNodeBodyRetargeter::SetDebugPoseMode(const EOculusXRBodyDebugPoseMode mode)
{
#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	DebugPoseMode = mode;
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
}

void FOculusXRAnimNodeBodyRetargeter::SetDebugDrawMode(const EOculusXRBodyDebugDrawMode mode)
{
#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	DebugDrawMode = mode;

	// Ensure we force an update to our Skeleton so if we're drawing the T-Pose it renders
	SourceReferenceInfo.Invalidate();
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
}

#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
const FString FOculusXRAnimNodeBodyRetargeter::kRestPoseDebugDrawCategory = "RestPoseDraw";

const float FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::kLineDrawThickness = 0.2f;
const float FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::kAxisLineLength = 2.0f;
const FString FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::kDefaultDrawQueue = "default";

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::AddSkeleton(const FAbstractRetargetSkeleton& RestSkeleton, const FTransform& MeshTransform, const FColor& color, const FString& drawQueue, const bool bRenderAxis)
{
	// Do NOT FScopeLock this function - the arrays will be protected in the calls to AddLineSegment and AddAxis
	for (int BoneIndex = 0; BoneIndex < RestSkeleton.GetNumBones(); ++BoneIndex)
	{
		const auto ParentBoneIndex = RestSkeleton.GetParentBoneIndex(BoneIndex);
		auto BoneTransform = RestSkeleton.GetLocalTransform(BoneIndex);
		if (ParentBoneIndex == INDEX_NONE)
		{
			BoneTransform = BoneTransform * MeshTransform;
		}
		else
		{
			const auto ParentTransform = RestSkeleton.GetComponentTransform(ParentBoneIndex) * MeshTransform;
			BoneTransform = BoneTransform * ParentTransform;
			AddLineSegment(ParentTransform.GetLocation(), BoneTransform.GetLocation(), color, drawQueue);
		}
		if (bRenderAxis)
		{
			AddAxis(BoneTransform.GetLocation(), BoneTransform.GetRotation(), drawQueue);
		}
	}
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::AddSkeletonMapping(
	const FOculusXRRetargetSkeletonEOculusXRBoneID& SourceSkeleton,
	const FAbstractRetargetSkeleton& TargetSkeleton,
	const TMap<EOculusXRBoneID, int>& SourceToTargetIdxMap,
	const FTransform& MeshTransform,
	const FColor& color,
	const FString& drawQueue)
{
	// Do NOT FScopeLock this function - the arrays will be protected in the calls to AddLineSegment and AddAxis
	for (const auto& sourceMappingPair : SourceToTargetIdxMap)
	{
		const int SourceIdx = SourceSkeleton.GetBoneIndex(sourceMappingPair.Key);
		if (SourceIdx != INDEX_NONE && TargetSkeleton.IsValidIndex(sourceMappingPair.Value))
		{
			const FTransform sourceTransform = SourceSkeleton.GetComponentTransform(SourceIdx) * MeshTransform;
			const FTransform targetTransform = TargetSkeleton.GetComponentTransform(sourceMappingPair.Value) * MeshTransform;
			AddLineSegment(sourceTransform.GetLocation(), targetTransform.GetLocation(), color, drawQueue);
		}
	}
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::AddLineSegment(const FVector& start, const FVector& end, const FColor& color, const FString& drawQueue)
{
	FScopeLock Lock(&MultiThreadLock);
	m_drawQueues.FindOrAdd(drawQueue).lines.Add(LineSegment{ start, end, color });
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::AddAxis(const FVector& position, const FQuat& rotation, const FString& drawQueue)
{
	FScopeLock Lock(&MultiThreadLock);
	m_drawQueues.FindOrAdd(drawQueue).axis.Add(Axis{ position, rotation });
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::AddAxis(const FTransform& transform, const FString& drawQueue)
{
	FScopeLock Lock(&MultiThreadLock);
	m_drawQueues.FindOrAdd(drawQueue).axis.Add(Axis{ transform.GetLocation(), transform.GetRotation() });
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::DrawFrame()
{
	const UWorld* World = GWorld;
#if WITH_EDITOR
	if (World && GIsEditor)
	{
		for (const FWorldContext& Context : GEngine->GetWorldContexts())
		{
			if (Context.WorldType == EWorldType::PIE)
			{
				World = Context.World();
				break;
			}
		}
	}
#endif // WITH_EDITOR
	if (!World)
	{
		return;
	}

	FScopeLock Lock(&MultiThreadLock);
	for (auto& queuePair : m_drawQueues)
	{
		for (LineSegment segment : queuePair.Value.lines)
		{
			DrawDebugLine(World, segment.start, segment.end, segment.color, false, -1, 1, kLineDrawThickness);
		}

		for (Axis axis : queuePair.Value.axis)
		{
			DrawDebugLine(World, axis.position, axis.position + (axis.rotation.GetAxisX() * kAxisLineLength), FColor::Red, false, -1, 1, kLineDrawThickness);
			DrawDebugLine(World, axis.position, axis.position + (axis.rotation.GetAxisY() * kAxisLineLength), FColor::Green, false, -1, 1, kLineDrawThickness);
			DrawDebugLine(World, axis.position, axis.position + (axis.rotation.GetAxisZ() * kAxisLineLength), FColor::Blue, false, -1, 1, kLineDrawThickness);
		}
	}
}

void FOculusXRAnimNodeBodyRetargeter::DebugDrawUtility::ClearDrawQueue(const FString& drawQueue)
{
	FScopeLock Lock(&MultiThreadLock);
	m_drawQueues.Remove(drawQueue);
}

#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRAnimNodeBodyRetargeter.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "OculusXRBodyRetargeter.h"
#include "OculusXRMovementTypes.h"
#include "OculusXRRetargetSkeleton.h"
#if !UE_BUILD_SHIPPING
#include "Tickable.h"
#define OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW 1
#else
#define OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW 0
#endif // !UE_BUILD_SHIPPING

class FOculusXRAnimNodeBodyRetargeter : public FOculusXRBodyRetargeter
{
public:
	FOculusXRAnimNodeBodyRetargeter() {}

	virtual void Initialize(
		const EOculusXRBodyRetargetingMode RetargetingMode,
		const EOculusXRBodyRetargetingRootMotionBehavior RootMotionBehavior,
		const EOculusXRAxis MeshForwardFacingDir,
		const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap) override;

	virtual bool RetargetFromBodyState(const FOculusXRBodyState& BodyState,
		const USkeletalMeshComponent* SkeletalMeshComponent,
		const float WorldScale,
		FPoseContext& Output) override;

	virtual void SetDebugPoseMode(const EOculusXRBodyDebugPoseMode mode) override;
	virtual void SetDebugDrawMode(const EOculusXRBodyDebugDrawMode mode) override;

	virtual EOculusXRBodyRetargetingMode GetRetargetingMode() override { return InitData.RetargetingMode; }
	virtual EOculusXRBodyRetargetingRootMotionBehavior GetRootMotionBehavior() { return InitData.RootMotionBehavior; }

private:
	struct InitializationData
	{
		EOculusXRBodyRetargetingMode RetargetingMode = EOculusXRBodyRetargetingMode::RotationAndPositions;
		EOculusXRBodyRetargetingRootMotionBehavior RootMotionBehavior = EOculusXRBodyRetargetingRootMotionBehavior::CombineToRoot;
		EOculusXRAxis MeshForwardFacingDir = EOculusXRAxis::Y;

		FTransform TargetFacingTransform = FTransform::Identity;
		FTransform TrackingSpaceToComponentSpace = FTransform::Identity;

		const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap = nullptr;
	};

	struct SourceInfo
	{
		inline bool IsValid() const { return BoneContainerSerialNumber != 0; }
		inline bool RequiresUpdate(const int ChangeCount, const uint16 ContainerSerialNumber) const
		{
			return !IsValid() || SourceChangeCount != ChangeCount || BoneContainerSerialNumber != ContainerSerialNumber;
		}

		// Invalidate allows us to force an update to the skeleton
		void Invalidate() { BoneContainerSerialNumber = 0; }

		FOculusXRBodySkeleton SourceReferenceSkeleton;
		uint16 BoneContainerSerialNumber = 0;
		int SourceChangeCount = 0;
		TMap<EOculusXRBoneID, int> SourceToTargetIdxMap;
		FOculusXRRetargetSkeletonEOculusXRBoneID SourceSkeleton;
		FOculusXRRetargetSkeletonEOculusXRBoneID LastFrameBodyState;
	};

	struct TargetSkeletonJointEntry
	{
		// Initialized Section
		const FCompactPoseBoneIndex BoneId = FCompactPoseBoneIndex(INDEX_NONE); // Bone ID in Target Space (Index Value)
		const int ParentIdx = INDEX_NONE;										// Target Index of Parent Joint (or NONE)
		FTransform LocalTransform = FTransform::Identity;						// Transform in child Local relative space
		FTransform ComponentTransform = FTransform::Identity;					// Transform in Component (root relative) space
		const EOculusXRBoneID sourceJointID = EOculusXRBoneID::None;			// Source Joint ID if this Joint is Mapped
		const float unmodifiedJointLength = 0.0f;								// LocalTransform Translation scale before scaling and deformation

		// Calculated Section
		int mappedAncestorIdx = INDEX_NONE; // Closest Parent that is mapped
		FTransform sourceJointLocalOffset = FTransform::Identity;
		float componentSpaceScale = 1.0f; // Scale is based on the difference between the joint lengths after the character is adjusted

		TArray<int> childJoints;	  // Array of all Children for this Joint
		TArray<int> childTwistJoints; // Array of Children that are Twist Joints (subset of childJoints)

		inline int GetNonTwistChildJointCount() const { return childJoints.Num() - childTwistJoints.Num(); }
	};

	struct TwistJointEntry
	{
		const int TargetSourceJointIdx = INDEX_NONE;
		const int TargetTwistJointIdx = INDEX_NONE;
		const int TargetTwistParentJointIdx = INDEX_NONE;
		const int TargetSourceParentJointIdx = INDEX_NONE; // Typically the same value as TargetTwistParentJointIdx unless this is a chain
		const FQuat TargetSourceLocalRotationOffset = FQuat::Identity;
		const FVector ProjectedSourceJointAlignmentLocalSpace = FVector::ZeroVector;
		const float RestPoseParentToSourceJointLength = 0.0f;
		const float ProjectedTwistJointLength = 0.0f;
		const float weight = 0.5f;
		const bool isRotateable = true;
	};

	// Extends FAbstractRetargetSkeleton specifically to reduce code needed to debug draw as a skeleton
	struct TargetSkeletonPoseData : public FAbstractRetargetSkeleton
	{
		virtual bool IsValidIndex(const int BoneIndex) const override
		{
			return BoneIndex >= 0 && BoneIndex < PoseData.Num();
		}
		virtual int GetNumBones() const override
		{
			return PoseData.Num();
		}
		virtual int GetParentBoneIndex(const int BoneIndex) const override
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].ParentIdx : INDEX_NONE;
		}
		virtual const FTransform& GetLocalTransform(const int BoneIndex) const override
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].LocalTransform : FTransform::Identity;
		}
		virtual const FTransform& GetComponentTransform(const int BoneIndex) const override
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].ComponentTransform : FTransform::Identity;
		}
		virtual bool IsEmpty() const override
		{
			return PoseData.IsEmpty();
		}
		EOculusXRBoneID GetSourceJointID(const int BoneIndex) const
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].sourceJointID : EOculusXRBoneID::None;
		}
		bool IsJointMappedToSource(const int BoneIndex) const
		{
			return GetSourceJointID(BoneIndex) != EOculusXRBoneID::None;
		}
		int GetMappedAncestorIndex(const int BoneIndex) const
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].mappedAncestorIdx : INDEX_NONE;
		}
		bool IsAncestorToBoneIndex(const int AncestorBoneIdx, const int BoneIndex) const
		{
			int parentBoneIdx = GetParentBoneIndex(BoneIndex);
			while (parentBoneIdx != INDEX_NONE)
			{
				if (parentBoneIdx == AncestorBoneIdx)
				{
					return true;
				}
				parentBoneIdx = GetParentBoneIndex(parentBoneIdx);
			}
			return false;
		}
		int GetChildJointCount(const int BoneIndex) const
		{
			return IsValidIndex(BoneIndex) ? PoseData[BoneIndex].childJoints.Num() : 0;
		}
		// Recursive function - depth first search
		int FindNextChildJointMappedToSource(const int ParentBoneIndex) const
		{
			if (IsValidIndex(ParentBoneIndex))
			{
				for (int childIdx : PoseData[ParentBoneIndex].childJoints)
				{
					if (IsJointMappedToSource(childIdx))
					{
						return childIdx;
					}
					int nextChildJointMapped = FindNextChildJointMappedToSource(childIdx);
					if (nextChildJointMapped != INDEX_NONE)
					{
						return nextChildJointMapped;
					}
				}
			}
			return INDEX_NONE;
		}

		TArray<TargetSkeletonJointEntry> PoseData;

		// Store Identified Twist Joint Chains here
		TMap<int, TwistJointEntry> TwistJoints;

		// This scale is based on the overall height scaling to align the
		// wrists of the target rig on the Z-Axis
		float GlobalComponentSpaceScale = 1.0f;
	};

	inline bool IsInitialized() const;

	// Update Section:

	// These functions are called during RetargetFromBodyState
	// Separated so we can better identify/mark in a profiler capture.
	bool UpdateSkeleton(const FOculusXRBodyState& BodyState,
		const FBoneContainer& BoneContainer,
		const USkeletalMeshComponent* SkeletalMeshComponent,
		const float WorldScale);

	bool ProcessFrameRetargeting(const FOculusXRBodyState& BodyState,
		const USkeletalMeshComponent* SkeletalMeshComponent,
		FPoseContext& Output);

	// Called from within ProcessFrameRetargeting
	void ProcessFrameInterpolateTwistJoints(TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const;
	void UpdateScaleForFrame(const int TargetIndex, TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const;
	void UpdateScaleForFrameRecursive(const int TargetIndex, const float scale, TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses) const;
	TTuple<float, float> GetFrameMaxCurrentAndUnModifiedJointLengths(int targetJointIndex, const TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& FramePoses, float currentLength = 0.0f, float unmodifiedLength = 0.0f) const;

	// End of Update Section

	// Setup/Calculation section - Called from UpdateSkeleton when a state change occurs

	void SetTargetToTPose();
	void CacheTwistJoints();
	void ApplyScaleAndProportion();
	void InitializeScaleAndOffsetData();
	TTuple<float, float> GetMaxCurrentAndUnModifiedJointLengths(int targetJointIndex, float currentLength = 0.0f, float unmodifiedLength = 0.0f) const;

	// End of Setup/Calculation section

	static void CaptureUnmappedJointChainRecursive(const TArray<TargetSkeletonJointEntry>& jointData, const int jointIdx, TArray<int>& outLinkArray);
	static void UpdateAllChildrenComponentFromLocalRecursive(TArray<TargetSkeletonJointEntry>& jointData, const int rootJointIdx);
	static void ScaleAllChildrenComponentSpaceRecursive(TArray<TargetSkeletonJointEntry>& jointData, const int rootJointIdx, const FVector& scalar);

	static void CalculateMappedAncestorValues(const SourceInfo& SourceReferenceInfo, const int CurrentMappedAncestorIdx, const int JointIdx, TargetSkeletonPoseData& TargetSkeleton);
	static TMap<FCompactPoseBoneIndex, EOculusXRBoneID> RecalculateMapping(const FBoneContainer& BoneContainer, const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap);

	static const float kTWIST_JOINT_MIN_ANGLE_THRESHOLD;
	static const TSet<EOculusXRBoneID> GenerateTPoseJointSet();
	static const TArray<EOculusXRBoneID> kALIGNABLE_HAND_JOINTS;
	static const TSet<EOculusXRBoneID> kTPOSE_ADJUSTABLE_JOINT_SET;
	static const TSet<EOculusXRBoneID> kTPOSE_SPECIAL_HANDLING_ADJUSTABLE_HAND_JOINTS;

	InitializationData InitData;
	SourceInfo SourceReferenceInfo;
	TMap<FCompactPoseBoneIndex, EOculusXRBoneID> TargetToSourceMap;
	TargetSkeletonPoseData TargetAdjustedRestPoseData;

#if OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
	static const FString kRestPoseDebugDrawCategory;

	class DebugDrawUtility : public FTickableGameObject
	{
	public:
		static const float kLineDrawThickness;
		static const float kAxisLineLength;
		static const FString kDefaultDrawQueue;

		struct LineSegment
		{
			FVector start;
			FVector end;
			FColor color;
		};

		struct Axis
		{
			FVector position;
			FQuat rotation;
		};

		struct DrawQueue
		{
			TArray<LineSegment> lines;
			TArray<Axis> axis;
		};

		DebugDrawUtility() {}
		virtual ~DebugDrawUtility() {}

		void AddSkeleton(const FAbstractRetargetSkeleton& RestSkeleton, const FTransform& MeshTransform, const FColor& color, const FString& drawQueue = kDefaultDrawQueue, const bool bRenderAxis = true);
		void AddSkeletonMapping(
			const FOculusXRRetargetSkeletonEOculusXRBoneID& SourceSkeleton,
			const FAbstractRetargetSkeleton& TargetSkeleton,
			const TMap<EOculusXRBoneID, int>& SourceToTargetIdxMap,
			const FTransform& MeshTransform, const FColor& color, const FString& drawQueue = kDefaultDrawQueue);
		void AddLineSegment(const FVector& start, const FVector& end, const FColor& color, const FString& drawQueue = kDefaultDrawQueue);
		void AddAxis(const FVector& position, const FQuat& rotation, const FString& drawQueue = kDefaultDrawQueue);
		void AddAxis(const FTransform& transform, const FString& drawQueue = kDefaultDrawQueue);
		void DrawFrame();
		void ClearDrawQueue(const FString& drawQueue = kDefaultDrawQueue);

		virtual void Tick(float DeltaTime) override
		{
			DrawFrame();
			ClearDrawQueue(); // Clear the Default Queue
		}

		virtual ETickableTickType GetTickableTickType() const override
		{
			return ETickableTickType::Always;
		}
		virtual TStatId GetStatId() const override
		{
			RETURN_QUICK_DECLARE_CYCLE_STAT(DebugDrawUtility, STATGROUP_Tickables);
		}
		virtual bool IsTickableWhenPaused() const
		{
			return true;
		}
		virtual bool IsTickableInEditor() const
		{
			return false;
		}

	private:
		mutable FCriticalSection MultiThreadLock;
		TMap<FString, DrawQueue> m_drawQueues;
	};

	DebugDrawUtility DebugDrawUtility;
	EOculusXRBodyDebugDrawMode DebugDrawMode = EOculusXRBodyDebugDrawMode::None;
	EOculusXRBodyDebugPoseMode DebugPoseMode = EOculusXRBodyDebugPoseMode::None;
#endif // OCULUS_XR_TRACKING_ENABLE_DEBUG_DRAW
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargeting.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargeting.h"

#define LOCTEXT_NAMESPACE "FOculusXRRetargetingModule"

DEFINE_LOG_CATEGORY(LogOculusXRRetargeting);

void FOculusXRRetargetingModule::StartupModule()
{
}

void FOculusXRRetargetingModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FOculusXRRetargetingModule, OculusXRRetargeting)

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargetingUtils.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetingUtils.h"

bool FOculusXRRetargetingUtils::GetUnitScaleFactorFromSettings(UWorld* World, float& OutWorldToMeters)
{
	if (IsValid(World))
	{
		if (const auto* WorldSettings = World->GetWorldSettings(); IsValid(WorldSettings))
		{
			OutWorldToMeters = WorldSettings->WorldToMeters;
			return true;
		}
	}
	return false;
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Private/OculusXRRetargetSkeleton.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetSkeleton.h"

#include "OculusXRRetargeting.h"

const EOculusXRBoneID FOculusXRRetargetSkeletonEOculusXRBoneID::kINVALID_BONE_ID = EOculusXRBoneID::None;
const FCompactPoseBoneIndex FOculusXRRetargetSkeletonFCompactPoseBoneIndex::kINVALID_BONE_ID = FCompactPoseBoneIndex(INDEX_NONE);

FOculusXRRetargetSkeletonEOculusXRBoneID Factory::FromOculusXRBodySkeleton(
	const FOculusXRBodySkeleton& SourceReferenceSkeleton,
	const FTransform& TrackingSpaceToComponentSpace)
{
	TArray<TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>> jointData;
	jointData.Reserve(SourceReferenceSkeleton.NumBones);

	for (int i = 0; i < SourceReferenceSkeleton.NumBones; ++i)
	{
		const auto& BoneData = SourceReferenceSkeleton.Bones[i];

		jointData.Add({ BoneData.BoneId,
			BoneData.ParentBoneIndex == EOculusXRBoneID::None ? INDEX_NONE : static_cast<int>(BoneData.ParentBoneIndex),
			FTransform::Identity, // No Local Transform data
			FTransform(
				SourceReferenceSkeleton.Bones[i].Orientation,
				SourceReferenceSkeleton.Bones[i].Position,
				FVector::OneVector)
				* TrackingSpaceToComponentSpace });
	}

	// Calculate the local transforms from the component transforms
	TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>::CalculateComponentToLocalSpace(jointData);

	return FOculusXRRetargetSkeletonEOculusXRBoneID(jointData);
}

FOculusXRRetargetSkeletonEOculusXRBoneID Factory::FromOculusXRBodyState(
	const FOculusXRBodyState& SourceFrameSkeleton,
	const FOculusXRBodySkeleton& SourceReferenceSkeleton,
	const FTransform& TrackingSpaceToComponentSpace,
	const EOculusXRBodyRetargetingRootMotionBehavior rootMotionBehavior)
{
	TArray<TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>> jointData;
	TMap<EOculusXRBoneID, int> BoneIdToIndexMap;
	jointData.Reserve(SourceReferenceSkeleton.NumBones);
	BoneIdToIndexMap.Reserve(SourceReferenceSkeleton.NumBones);

	// Use this if we're Combining the Hip Translation/Rotation to
	// Root - if the Tracking expands, the capsule will float if we use
	// the hip skeleton offset as a reference.
	float minZPosition = FLT_MAX;
	float minRestZPosition = FLT_MAX;

	for (int i = 0; i < SourceReferenceSkeleton.NumBones; ++i)
	{
		const auto& Joint = SourceFrameSkeleton.Joints[i];
		const auto& BoneData = SourceReferenceSkeleton.Bones[i];

		FTransform frameTransform(Joint.Orientation, Joint.Position, FVector::OneVector);
		const EOculusXRBoneID TrackingBoneId = Joint.bIsValid ? BoneData.BoneId : EOculusXRBoneID::None;

		jointData.Add({ TrackingBoneId,
			BoneData.ParentBoneIndex == EOculusXRBoneID::None ? INDEX_NONE : static_cast<int>(BoneData.ParentBoneIndex),
			FTransform::Identity, // No Local Transform data
			frameTransform * TrackingSpaceToComponentSpace });

		if (TrackingBoneId != EOculusXRBoneID::BodyRoot)
		{
			minZPosition = FMath::Min(minZPosition, frameTransform.GetLocation().Z);
			minRestZPosition = FMath::Min(minRestZPosition, BoneData.Position.Z);
		}

		if (TrackingBoneId != EOculusXRBoneID::None)
		{
			check(!BoneIdToIndexMap.Contains(TrackingBoneId));
			BoneIdToIndexMap.Add(TrackingBoneId, i);
		}
	}

	// Calculate the local transforms from the component transforms
	TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>::CalculateComponentToLocalSpace(jointData);

	// If mode is CombineToRoot, we'll shift the excess up motion from the hip to the root
	// (So when the character jumps, the root translates up)
	// We'll also extract the Yaw from the hip and shift it to the root.
	// This allows for better compatibility with Locomotion systems
	if (FOculusXRBodyRetargeter::IsModifiedRootBehavior(rootMotionBehavior) && BoneIdToIndexMap.Contains(EOculusXRBoneID::BodyHips) && BoneIdToIndexMap.Contains(EOculusXRBoneID::BodyRoot))
	{
		const int HipJointIdx = BoneIdToIndexMap[EOculusXRBoneID::BodyHips];
		const int rootJointIdx = BoneIdToIndexMap[EOculusXRBoneID::BodyRoot];

		const auto& HipRest = SourceReferenceSkeleton.Bones[HipJointIdx];
		const auto& HipFrame = SourceFrameSkeleton.Joints[HipJointIdx];
		const auto& RootRest = SourceReferenceSkeleton.Bones[rootJointIdx];

		TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>& HipJointEntry = jointData[HipJointIdx];
		TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>& RootJoint = jointData[rootJointIdx];

		// First cover translation.  Use the minZPosition we calculated in the first pass to accommodate
		// any error introduced in the tracker (it allows for ~10% scaling which can result in the standing
		// hip translation being longer than the T-Pose skeleton).
		const float CalculatedHipHeight = HipFrame.Position.Z - minZPosition + FMath::Max(minRestZPosition, 0.0f);
		// Hack 1.05 multiplier - 5% buffer due to floaty solver behavior (keeps feet/capsule on the floor unless jumping)
		const float MaxHipHeight = FMath::Max(HipRest.Position.Z, CalculatedHipHeight) * 1.05f;
		const float ExcessHipTranslation = FMath::Max(HipFrame.Position.Z - MaxHipHeight, 0.0f);

		if (ExcessHipTranslation > 0.0f)
		{
			const FVector ExcessHipTranslationVector(0.0f, 0.0f, ExcessHipTranslation);
			HipJointEntry.LocalTransform.SetLocation(HipJointEntry.LocalTransform.GetLocation() - ExcessHipTranslationVector);
			RootJoint.LocalTransform.SetLocation(RootJoint.LocalTransform.GetLocation() + ExcessHipTranslationVector);
		}

		// Calculate the Yaw next - we need to flatten the Hip so we can determine it's yaw relative to the rest pose
		const FQuat restLocalRotation = FQuat(RootRest.Orientation).Inverse() * FQuat(HipRest.Orientation);
		const FQuat frameLocalRotation(HipJointEntry.LocalTransform.GetRotation());

		const FVector flatRightDirection = restLocalRotation.RotateVector(FVector::RightVector);
		const FVector frameFwdVector = frameLocalRotation.RotateVector(FVector::ForwardVector);
		const FVector flatUpVector = frameFwdVector.Cross(flatRightDirection).GetSafeNormal();
		const FVector flatFwdVector = flatRightDirection.Cross(flatUpVector).GetSafeNormal();
		const FQuat flatFrameRotation = FRotationMatrix::MakeFromXZ(flatFwdVector, flatUpVector).ToQuat();
		const FQuat flatRotationDelta = (restLocalRotation * flatFrameRotation.Inverse()).GetNormalized();

		// Once calculated, apply the rotation to pull the hip back to identity facing, then apply the inverse to the root.
		HipJointEntry.LocalTransform.SetRotation((flatRotationDelta * HipJointEntry.LocalTransform.GetRotation()).GetNormalized());

		if (rootMotionBehavior == EOculusXRBodyRetargetingRootMotionBehavior::ZeroOutRootTranslationHipYaw)
		{
			// Reset the Root joint to it's RestPose (basically Identity Matrix)
			RootJoint.LocalTransform = FTransform(RootRest.Orientation, RootRest.Position, FVector::OneVector) * TrackingSpaceToComponentSpace;
		}
		else
		{
			RootJoint.LocalTransform.SetRotation((RootJoint.LocalTransform.GetRotation() * flatRotationDelta.Inverse()).GetNormalized());
		}

		// Recalculate our skeleton from local space since we changed the root and hips
		TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>::CalculateLocalToComponentSpace(jointData);
	}

	return FOculusXRRetargetSkeletonEOculusXRBoneID(jointData);
}

FOculusXRRetargetSkeletonFCompactPoseBoneIndex Factory::FromBoneContainer(
	const FBoneContainer& TargetBoneContainer)
{
	TArray<TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>> jointData;

	// TODO: Fix to be more bulletproof - Based on an assumption that the Joints are
	// sorted from Parent to Child.  If it isn't, then the Parent Transform/Index may not get calculated before the child.
	TMap<FCompactPoseBoneIndex, int> jointIdxMap;

	// Get full skeleton
	const auto& TargetReferenceSkeleton = TargetBoneContainer.GetReferenceSkeleton();

	// Get bones used in current LOD
	const auto& BoneIndicesArray = TargetBoneContainer.GetBoneIndicesArray();

	jointData.Reserve(BoneIndicesArray.Num());
	jointIdxMap.Reserve(BoneIndicesArray.Num());

	for (int i = 0; i < BoneIndicesArray.Num(); ++i)
	{
		// BoneIndex = Index in full skeleton, only used to get transform, not parent
		// BoneId = Index in bone container / LOD skeleton, used to find correct parent index

		const auto BoneIndex = BoneIndicesArray[i];
		const auto BoneId = TargetBoneContainer.MakeCompactPoseIndex(FMeshPoseBoneIndex(BoneIndex));
		const auto ParentBoneId = TargetBoneContainer.GetParentBoneIndex(BoneId);

		jointData.Add({ BoneId,
			jointIdxMap.Contains(ParentBoneId) ? jointIdxMap[ParentBoneId] : INDEX_NONE,
			TargetReferenceSkeleton.GetRawRefBonePose()[BoneIndex],
			FTransform::Identity });

		jointIdxMap.Add(BoneId, i);
	}

	// Calculate the component transforms from the local transforms
	TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>::CalculateLocalToComponentSpace(jointData);

	return FOculusXRRetargetSkeletonFCompactPoseBoneIndex(jointData);
}

FOculusXRRetargetSkeletonFCompactPoseBoneIndex Factory::FromComponentSpaceTransformArray(
	const FAbstractRetargetSkeleton& BaseSkeleton,
	const TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& ComponentSpaceTransformPairs)
{
	check(BaseSkeleton.GetNumBones() == ComponentSpaceTransformPairs.Num());
	TArray<TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>> jointData;
	jointData.Reserve(ComponentSpaceTransformPairs.Num());

	for (int i = 0; i < ComponentSpaceTransformPairs.Num(); ++i)
	{
		jointData.Add({ ComponentSpaceTransformPairs[i].Get<FCompactPoseBoneIndex>(),
			BaseSkeleton.GetParentBoneIndex(i),
			FTransform::Identity,
			ComponentSpaceTransformPairs[i].Get<FTransform>() });
	}

	// Calculate the local transforms from the component transforms
	TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>::CalculateComponentToLocalSpace(jointData);

	return FOculusXRRetargetSkeletonFCompactPoseBoneIndex(jointData);
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXRBodyTracking.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "OculusXRLiveLinkRetargetBodyAsset.h"
#include "OculusXRBodyRetargeter.h"
#include "OculusXRRetargetSkeleton.h"
#include "Animation/AnimNodeBase.h"
#include "AnimNode_OculusXRBodyTracking.generated.h"

USTRUCT(Blueprintable)
struct OCULUSXRRETARGETING_API FAnimNode_OculusXRBodyTracking : public FAnimNode_Base
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Input)
	FPoseLink InputPose;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Debug, meta = (PinShownByDefault))
	EOculusXRBodyDebugPoseMode DebugPoseMode;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Debug, meta = (PinShownByDefault))
	EOculusXRBodyDebugDrawMode DebugDrawMode;
	/**
	 * Remapping from bone ID to target skeleton's bone name.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OculusXR|BodyTracking")
	TMap<EOculusXRBoneID, FName> BoneRemapping = {
		{ EOculusXRBoneID::BodyRoot, "root" },
		{ EOculusXRBoneID::BodyHips, "pelvis" },
		{ EOculusXRBoneID::BodySpineLower, "spine_01" },
		{ EOculusXRBoneID::BodySpineMiddle, "spine_02" },
		{ EOculusXRBoneID::BodySpineUpper, "spine_04" },
		{ EOculusXRBoneID::BodyChest, "spine_05" },
		{ EOculusXRBoneID::BodyNeck, "neck_02" },
		{ EOculusXRBoneID::BodyHead, "head" },

		{ EOculusXRBoneID::BodyLeftShoulder, "clavicle_l" },
		{ EOculusXRBoneID::BodyLeftScapula, NAME_None },
		{ EOculusXRBoneID::BodyLeftArmUpper, "upperarm_l" },
		{ EOculusXRBoneID::BodyLeftArmLower, "lowerarm_l" },
		{ EOculusXRBoneID::BodyLeftHandWristTwist, NAME_None },

		{ EOculusXRBoneID::BodyRightShoulder, "clavicle_r" },
		{ EOculusXRBoneID::BodyRightScapula, NAME_None },
		{ EOculusXRBoneID::BodyRightArmUpper, "upperarm_r" },
		{ EOculusXRBoneID::BodyRightArmLower, "lowerarm_r" },
		{ EOculusXRBoneID::BodyRightHandWristTwist, NAME_None },

		{ EOculusXRBoneID::BodyLeftHandPalm, NAME_None },
		{ EOculusXRBoneID::BodyLeftHandWrist, "hand_l" },
		{ EOculusXRBoneID::BodyLeftHandThumbMetacarpal, "thumb_01_l" },
		{ EOculusXRBoneID::BodyLeftHandThumbProximal, "thumb_02_l" },
		{ EOculusXRBoneID::BodyLeftHandThumbDistal, "thumb_03_l" },
		{ EOculusXRBoneID::BodyLeftHandThumbTip, NAME_None },
		{ EOculusXRBoneID::BodyLeftHandIndexMetacarpal, "index_metacarpal_l" },
		{ EOculusXRBoneID::BodyLeftHandIndexProximal, "index_01_l" },
		{ EOculusXRBoneID::BodyLeftHandIndexIntermediate, "index_02_l" },
		{ EOculusXRBoneID::BodyLeftHandIndexDistal, "index_03_l" },
		{ EOculusXRBoneID::BodyLeftHandIndexTip, NAME_None },
		{ EOculusXRBoneID::BodyLeftHandMiddleMetacarpal, "middle_metacarpal_l" },
		{ EOculusXRBoneID::BodyLeftHandMiddleProximal, "middle_01_l" },
		{ EOculusXRBoneID::BodyLeftHandMiddleIntermediate, "middle_02_l" },
		{ EOculusXRBoneID::BodyLeftHandMiddleDistal, "middle_03_l" },
		{ EOculusXRBoneID::BodyLeftHandMiddleTip, NAME_None },
		{ EOculusXRBoneID::BodyLeftHandRingMetacarpal, "ring_metacarpal_l" },
		{ EOculusXRBoneID::BodyLeftHandRingProximal, "ring_01_l" },
		{ EOculusXRBoneID::BodyLeftHandRingIntermediate, "ring_02_l" },
		{ EOculusXRBoneID::BodyLeftHandRingDistal, "ring_03_l" },
		{ EOculusXRBoneID::BodyLeftHandRingTip, NAME_None },
		{ EOculusXRBoneID::BodyLeftHandLittleMetacarpal, "pinky_metacarpal_l" },
		{ EOculusXRBoneID::BodyLeftHandLittleProximal, "pinky_01_l" },
		{ EOculusXRBoneID::BodyLeftHandLittleIntermediate, "pinky_02_l" },
		{ EOculusXRBoneID::BodyLeftHandLittleDistal, "pinky_03_l" },
		{ EOculusXRBoneID::BodyLeftHandLittleTip, NAME_None },

		{ EOculusXRBoneID::BodyRightHandPalm, NAME_None },
		{ EOculusXRBoneID::BodyRightHandWrist, "hand_r" },
		{ EOculusXRBoneID::BodyRightHandThumbMetacarpal, "thumb_01_r" },
		{ EOculusXRBoneID::BodyRightHandThumbProximal, "thumb_02_r" },
		{ EOculusXRBoneID::BodyRightHandThumbDistal, "thumb_03_r" },
		{ EOculusXRBoneID::BodyRightHandThumbTip, NAME_None },
		{ EOculusXRBoneID::BodyRightHandIndexMetacarpal, "index_metacarpal_r" },
		{ EOculusXRBoneID::BodyRightHandIndexProximal, "index_01_r" },
		{ EOculusXRBoneID::BodyRightHandIndexIntermediate, "index_02_r" },
		{ EOculusXRBoneID::BodyRightHandIndexDistal, "index_03_r" },
		{ EOculusXRBoneID::BodyRightHandIndexTip, NAME_None },
		{ EOculusXRBoneID::BodyRightHandMiddleMetacarpal, "middle_metacarpal_r" },
		{ EOculusXRBoneID::BodyRightHandMiddleProximal, "middle_01_r" },
		{ EOculusXRBoneID::BodyRightHandMiddleIntermediate, "middle_02_r" },
		{ EOculusXRBoneID::BodyRightHandMiddleDistal, "middle_03_r" },
		{ EOculusXRBoneID::BodyRightHandMiddleTip, NAME_None },
		{ EOculusXRBoneID::BodyRightHandRingMetacarpal, "ring_metacarpal_r" },
		{ EOculusXRBoneID::BodyRightHandRingProximal, "ring_01_r" },
		{ EOculusXRBoneID::BodyRightHandRingIntermediate, "ring_02_r" },
		{ EOculusXRBoneID::BodyRightHandRingDistal, "ring_03_r" },
		{ EOculusXRBoneID::BodyRightHandRingTip, NAME_None },
		{ EOculusXRBoneID::BodyRightHandLittleMetacarpal, "pinky_metacarpal_r" },
		{ EOculusXRBoneID::BodyRightHandLittleProximal, "pinky_01_r" },
		{ EOculusXRBoneID::BodyRightHandLittleIntermediate, "pinky_02_r" },
		{ EOculusXRBoneID::BodyRightHandLittleDistal, "pinky_03_r" },
		{ EOculusXRBoneID::BodyRightHandLittleTip, NAME_None },

		{ EOculusXRBoneID::BodyLeftUpperLeg, "thigh_l" },
		{ EOculusXRBoneID::BodyLeftLowerLeg, "calf_l" },
		{ EOculusXRBoneID::BodyLeftFootAnkleTwist, NAME_None },
		{ EOculusXRBoneID::BodyLeftFootAnkle, "foot_l" },
		{ EOculusXRBoneID::BodyLeftFootSubtalar, NAME_None },
		{ EOculusXRBoneID::BodyLeftFootTransverse, NAME_None },
		{ EOculusXRBoneID::BodyLeftFootBall, "ball_l" },
		{ EOculusXRBoneID::BodyRightUpperLeg, "thigh_r" },
		{ EOculusXRBoneID::BodyRightLowerLeg, "calf_r" },
		{ EOculusXRBoneID::BodyRightFootAnkleTwist, NAME_None },
		{ EOculusXRBoneID::BodyRightFootAnkle, "foot_r" },
		{ EOculusXRBoneID::BodyRightFootSubtalar, NAME_None },
		{ EOculusXRBoneID::BodyRightFootTransverse, NAME_None },
		{ EOculusXRBoneID::BodyRightFootBall, "ball_r" },
	};

	/**
	 * Switch between retargeting modes.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OculusXR|BodyTracking", meta = (PinShownByDefault))
	EOculusXRBodyRetargetingMode RetargetingMode = EOculusXRBodyRetargetingMode::RotationAndPositions;

	/**
	 * Forward vector axis is the direction towards which the target mesh is oriented.
	 */
	UPROPERTY(EditDefaultsOnly, Category = "OculusXR|BodyTracking")
	EOculusXRAxis ForwardMesh = EOculusXRAxis::Y;

	/**
	 * Behavior for Root Motion - Combine to Root is more compatible with most Locomotion systems.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OculusXR|BodyTracking", meta = (PinShownByDefault))
	EOculusXRBodyRetargetingRootMotionBehavior RootMotionBehavior = EOculusXRBodyRetargetingRootMotionBehavior::CombineToRoot;

	virtual void Initialize_AnyThread(const FAnimationInitializeContext& Context) override;
	virtual void PreUpdate(const UAnimInstance* InAnimInstance) override;
	virtual void Update_AnyThread(const FAnimationUpdateContext& Context) override;
	virtual void Evaluate_AnyThread(FPoseContext& Output) override;

private:
	TSharedPtr<FOculusXRBodyRetargeter> RetargeterInstance;

	// U Type Data - cached from other location
	USkeletalMeshComponent* SkeletalMeshComponent = nullptr;
	USkeleton* Skeleton = nullptr;

	float Scale = 100.f;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXREyeTracking.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "OculusXRLiveLinkRetargetBodyAsset.h"
#include "OculusXRRetargetSkeleton.h"
#include "Animation/AnimNodeBase.h"
#include "OculusXRMorphTargetsController.h"
#include "AnimNode_OculusXREyeTracking.generated.h"

USTRUCT(Blueprintable)
struct OCULUSXRRETARGETING_API FAnimNode_OculusXREyeTracking : public FAnimNode_Base
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Input)
	FPoseLink InputPose;

	virtual void Initialize_AnyThread(const FAnimationInitializeContext& Context) override;
	virtual void PreUpdate(const UAnimInstance* InAnimInstance) override;
	virtual void Update_AnyThread(const FAnimationUpdateContext& Context) override;
	virtual void Evaluate_AnyThread(FPoseContext& Output) override;

	UPROPERTY(EditDefaultsOnly, Category = "OculusXR|EyeTracking")
	FName LeftEyeBone = "LeftEye";

	UPROPERTY(EditDefaultsOnly, Category = "OculusXR|EyeTracking")
	FName RightEyeBone = "RightEye";

private:
	FQuat InitialLeftRotation;
	FQuat InitialRightRotation;

	bool HasSetInitialRotations = false;
	void RecalculateInitialRotations(FBoneContainer);
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/AnimNode_OculusXRFaceTracking.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "OculusXRLiveLinkRetargetBodyAsset.h"
#include "OculusXRRetargetSkeleton.h"
#include "Animation/AnimNodeBase.h"
#include "OculusXRMorphTargetsController.h"
#include "AnimNode_OculusXRFaceTracking.generated.h"

USTRUCT(BlueprintType)
struct OCULUSXRRETARGETING_API FOculusXRFaceExpressionModifierNew
{
	GENERATED_BODY()
public:
	FOculusXRFaceExpressionModifierNew()
		: MinValue(0.f)
		, MaxValue(1.f)
		, Multiplier(1.f)
	{
	}

	UPROPERTY(EditAnywhere, Category = "OculusXR|Movement")
	float MinValue;

	UPROPERTY(EditAnywhere, Category = "OculusXR|Movement")
	float MaxValue;

	UPROPERTY(EditAnywhere, Category = "OculusXR|Movement")
	float Multiplier;
};

USTRUCT(BlueprintType)
struct OCULUSXRRETARGETING_API FOculusXRExpressionCurves
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = "OculusXR|Movement")
	TArray<FName> CurveNames;
};

USTRUCT(Blueprintable)
struct OCULUSXRRETARGETING_API FAnimNode_OculusXRFaceTracking : public FAnimNode_Base
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Input)
	FPoseLink InputPose;

	virtual void Initialize_AnyThread(const FAnimationInitializeContext& Context) override;
	virtual void PreUpdate(const UAnimInstance* InAnimInstance) override;
	virtual void Update_AnyThread(const FAnimationUpdateContext& Context) override;
	virtual void Evaluate_AnyThread(FPoseContext& Output) override;

	/**
	 * Remapping from bone ID to target skeleton's bone name.
	 */
	UPROPERTY(EditDefaultsOnly, Category = "OculusXR|FaceTracking")
	TMap<EOculusXRFaceExpression, FOculusXRExpressionCurves> ExpressionNames = {
		{ EOculusXRFaceExpression::BrowLowererL, FOculusXRExpressionCurves{ { FName("browLowerer_L") } } },
		{ EOculusXRFaceExpression::BrowLowererR, FOculusXRExpressionCurves{ { FName("browLowerer_R") } } },
		{ EOculusXRFaceExpression::CheekPuffL, FOculusXRExpressionCurves{ { FName("cheekPuff_L") } } },
		{ EOculusXRFaceExpression::CheekPuffR, FOculusXRExpressionCurves{ { FName("cheekPuff_R") } } },
		{ EOculusXRFaceExpression::CheekRaiserL, FOculusXRExpressionCurves{ { FName("cheekRaiser_L") } } },
		{ EOculusXRFaceExpression::CheekRaiserR, FOculusXRExpressionCurves{ { FName("cheekRaiser_R") } } },
		{ EOculusXRFaceExpression::CheekSuckL, FOculusXRExpressionCurves{ { FName("cheekSuck_L") } } },
		{ EOculusXRFaceExpression::CheekSuckR, FOculusXRExpressionCurves{ { FName("cheekSuck_R") } } },
		{ EOculusXRFaceExpression::ChinRaiserB, FOculusXRExpressionCurves{ { FName("chinRaiser_B") } } },
		{ EOculusXRFaceExpression::ChinRaiserT, FOculusXRExpressionCurves{ { FName("chinRaiser_T") } } },
		{ EOculusXRFaceExpression::DimplerL, FOculusXRExpressionCurves{ { FName("dimpler_L") } } },
		{ EOculusXRFaceExpression::DimplerR, FOculusXRExpressionCurves{ { FName("dimpler_R") } } },
		{ EOculusXRFaceExpression::EyesClosedL, FOculusXRExpressionCurves{ { FName("eyesClosed_L") } } },
		{ EOculusXRFaceExpression::EyesClosedR, FOculusXRExpressionCurves{ { FName("eyesClosed_R") } } },
		{ EOculusXRFaceExpression::EyesLookDownL, FOculusXRExpressionCurves{ { FName("eyesLookDown_L") } } },
		{ EOculusXRFaceExpression::EyesLookDownR, FOculusXRExpressionCurves{ { FName("eyesLookDown_R") } } },
		{ EOculusXRFaceExpression::EyesLookLeftL, FOculusXRExpressionCurves{ { FName("eyesLookLeft_L") } } },
		{ EOculusXRFaceExpression::EyesLookLeftR, FOculusXRExpressionCurves{ { FName("eyesLookLeft_R") } } },
		{ EOculusXRFaceExpression::EyesLookRightL, FOculusXRExpressionCurves{ { FName("eyesLookRight_L") } } },
		{ EOculusXRFaceExpression::EyesLookRightR, FOculusXRExpressionCurves{ { FName("eyesLookRight_R") } } },
		{ EOculusXRFaceExpression::EyesLookUpL, FOculusXRExpressionCurves{ { FName("eyesLookUp_L") } } },
		{ EOculusXRFaceExpression::EyesLookUpR, FOculusXRExpressionCurves{ { FName("eyesLookUp_R") } } },
		{ EOculusXRFaceExpression::InnerBrowRaiserL, FOculusXRExpressionCurves{ { FName("innerBrowRaiser_L") } } },
		{ EOculusXRFaceExpression::InnerBrowRaiserR, FOculusXRExpressionCurves{ { FName("innerBrowRaiser_R") } } },
		{ EOculusXRFaceExpression::JawDrop, FOculusXRExpressionCurves{ { FName("jawDrop") } } },
		{ EOculusXRFaceExpression::JawSidewaysLeft, FOculusXRExpressionCurves{ { FName("jawSidewaysLeft") } } },
		{ EOculusXRFaceExpression::JawSidewaysRight, FOculusXRExpressionCurves{ { FName("jawSidewaysRight") } } },
		{ EOculusXRFaceExpression::JawThrust, FOculusXRExpressionCurves{ { FName("jawThrust") } } },
		{ EOculusXRFaceExpression::LidTightenerL, FOculusXRExpressionCurves{ { FName("lidTightener_L") } } },
		{ EOculusXRFaceExpression::LidTightenerR, FOculusXRExpressionCurves{ { FName("lidTightener_R") } } },
		{ EOculusXRFaceExpression::LipCornerDepressorL, FOculusXRExpressionCurves{ { FName("lipCornerDepressor_L") } } },
		{ EOculusXRFaceExpression::LipCornerDepressorR, FOculusXRExpressionCurves{ { FName("lipCornerDepressor_R") } } },
		{ EOculusXRFaceExpression::LipCornerPullerL, FOculusXRExpressionCurves{ { FName("lipCornerPuller_L") } } },
		{ EOculusXRFaceExpression::LipCornerPullerR, FOculusXRExpressionCurves{ { FName("lipCornerPuller_R") } } },
		{ EOculusXRFaceExpression::LipFunnelerLB, FOculusXRExpressionCurves{ { FName("lipFunneler_LB") } } },
		{ EOculusXRFaceExpression::LipFunnelerLT, FOculusXRExpressionCurves{ { FName("lipFunneler_LT") } } },
		{ EOculusXRFaceExpression::LipFunnelerRB, FOculusXRExpressionCurves{ { FName("lipFunneler_RB") } } },
		{ EOculusXRFaceExpression::LipFunnelerRT, FOculusXRExpressionCurves{ { FName("lipFunneler_RT") } } },
		{ EOculusXRFaceExpression::LipPressorL, FOculusXRExpressionCurves{ { FName("lipPressor_L") } } },
		{ EOculusXRFaceExpression::LipPressorR, FOculusXRExpressionCurves{ { FName("lipPressor_R") } } },
		{ EOculusXRFaceExpression::LipPuckerL, FOculusXRExpressionCurves{ { FName("lipPucker_L") } } },
		{ EOculusXRFaceExpression::LipPuckerR, FOculusXRExpressionCurves{ { FName("lipPucker_R") } } },
		{ EOculusXRFaceExpression::LipStretcherL, FOculusXRExpressionCurves{ { FName("lipStretcher_L") } } },
		{ EOculusXRFaceExpression::LipStretcherR, FOculusXRExpressionCurves{ { FName("lipStretcher_R") } } },
		{ EOculusXRFaceExpression::LipSuckLB, FOculusXRExpressionCurves{ { FName("lipSuck_LB") } } },
		{ EOculusXRFaceExpression::LipSuckLT, FOculusXRExpressionCurves{ { FName("lipSuck_LT") } } },
		{ EOculusXRFaceExpression::LipSuckRB, FOculusXRExpressionCurves{ { FName("lipSuck_RB") } } },
		{ EOculusXRFaceExpression::LipSuckRT, FOculusXRExpressionCurves{ { FName("lipSuck_RT") } } },
		{ EOculusXRFaceExpression::LipTightenerL, FOculusXRExpressionCurves{ { FName("lipTightener_L") } } },
		{ EOculusXRFaceExpression::LipTightenerR, FOculusXRExpressionCurves{ { FName("lipTightener_R") } } },
		{ EOculusXRFaceExpression::LipsToward, FOculusXRExpressionCurves{ { FName("lipsToward") } } },
		{ EOculusXRFaceExpression::LowerLipDepressorL, FOculusXRExpressionCurves{ { FName("lowerLipDepressor_L") } } },
		{ EOculusXRFaceExpression::LowerLipDepressorR, FOculusXRExpressionCurves{ { FName("lowerLipDepressor_R") } } },
		{ EOculusXRFaceExpression::MouthLeft, FOculusXRExpressionCurves{ { FName("mouthLeft") } } },
		{ EOculusXRFaceExpression::MouthRight, FOculusXRExpressionCurves{ { FName("mouthRight") } } },
		{ EOculusXRFaceExpression::NoseWrinklerL, FOculusXRExpressionCurves{ { FName("noseWrinkler_L") } } },
		{ EOculusXRFaceExpression::NoseWrinklerR, FOculusXRExpressionCurves{ { FName("noseWrinkler_R") } } },
		{ EOculusXRFaceExpression::OuterBrowRaiserL, FOculusXRExpressionCurves{ { FName("outerBrowRaiser_L") } } },
		{ EOculusXRFaceExpression::OuterBrowRaiserR, FOculusXRExpressionCurves{ { FName("outerBrowRaiser_R") } } },
		{ EOculusXRFaceExpression::UpperLidRaiserL, FOculusXRExpressionCurves{ { FName("upperLidRaiser_L") } } },
		{ EOculusXRFaceExpression::UpperLidRaiserR, FOculusXRExpressionCurves{ { FName("upperLidRaiser_R") } } },
		{ EOculusXRFaceExpression::UpperLipRaiserL, FOculusXRExpressionCurves{ { FName("upperLipRaiser_L") } } },
		{ EOculusXRFaceExpression::UpperLipRaiserR, FOculusXRExpressionCurves{ { FName("upperLipRaiser_R") } } },
		{ EOculusXRFaceExpression::TongueTipInterdental, FOculusXRExpressionCurves{ { FName("tongueTipInterdental") } } },
		{ EOculusXRFaceExpression::TongueTipAlveolar, FOculusXRExpressionCurves{ { FName("tongueTipAlveolar") } } },
		{ EOculusXRFaceExpression::TongueFrontDorsalPalate, FOculusXRExpressionCurves{ { FName("tongueFrontDorsalPalate") } } },
		{ EOculusXRFaceExpression::TongueMidDorsalPalate, FOculusXRExpressionCurves{ { FName("tongueMidDorsalPalate") } } },
		{ EOculusXRFaceExpression::TongueBackDorsalVelar, FOculusXRExpressionCurves{ { FName("tongueBackDorsalVelar") } } },
		{ EOculusXRFaceExpression::TongueOut, FOculusXRExpressionCurves{ { FName("tongueOut") } } }
	};

	UPROPERTY(EditDefaultsOnly, Category = "OculusXR|FaceTracking")
	TMap<EOculusXRFaceExpression, FOculusXRFaceExpressionModifierNew> ExpressionModifiers;

private:
	USkeletalMeshComponent* SkeletalMeshComponent;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRBodyRetargeter.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "Animation/AnimNodeBase.h"
#include "OculusXRLiveLinkRetargetBodyAsset.h"
#include "OculusXRMovementTypes.h"

UENUM(BlueprintType, meta = (DisplayName = "Retargeting mode"))
enum class EOculusXRBodyRetargetingMode : uint8
{
	RotationAndPositions UMETA(DisplayName = "Rotation & Positions"),
	RotationAndPositionsHandsRotationOnly UMETA(DisplayName = "Rotation & Position - Hands Rotation Only"),
	RotationOnlyUniformScale UMETA(DisplayName = "Rotation Only - Uniform Scale"),
	RotationOnlyNoScaling UMETA(DisplayName = "Rotation Only - No Scaling"),
};

UENUM(BlueprintType, meta = (DisplayName = "Root Motion Behavior"))
enum class EOculusXRBodyRetargetingRootMotionBehavior : uint8
{
	CombineToRoot UMETA(DisplayName = "Combine Motion Into Root"),
	RootFlatTranslationHipRotation UMETA(DisplayName = "Root Translation with Full Hip Rotation"),
	ZeroOutRootTranslationHipYaw UMETA(DisplayName = "Zero Root Translation with Zero Hip Yaw"),
};

UENUM(BlueprintType, meta = (DisplayName = "DebugDraw mode"))
enum class EOculusXRBodyDebugDrawMode : uint8
{
	None UMETA(DisplayName = "None"),
	RestPose UMETA(DisplayName = "Rest Poses"),
	RestPoseWithMapping UMETA(DisplayName = "Rest Pose With Mapping"),
	FramePose UMETA(DisplayName = "Frame Pose"),
	FramePoseWithMapping UMETA(DisplayName = "Frame Pose With Mapping"),
};

UENUM(BlueprintType, meta = (DisplayName = "Pose Debug mode"))
enum class EOculusXRBodyDebugPoseMode : uint8
{
	None UMETA(DisplayName = "None"),
	RestPose UMETA(DisplayName = "Rest Pose"),
};

class OCULUSXRRETARGETING_API FOculusXRBodyRetargeter
{
public:
	virtual ~FOculusXRBodyRetargeter() = default;
	virtual void Initialize(const EOculusXRBodyRetargetingMode RetargetingMode,
		const EOculusXRBodyRetargetingRootMotionBehavior RootMotionBehavior,
		const EOculusXRAxis MeshForwardFacingDir,
		const TMap<EOculusXRBoneID, FName>* SourceToTargetNameMap) = 0;

	virtual bool RetargetFromBodyState(const FOculusXRBodyState& BodyState,
		const USkeletalMeshComponent* SkeletalMeshComponent,
		const float WorldScale,
		FPoseContext& Output) = 0;

	virtual EOculusXRBodyRetargetingMode GetRetargetingMode() = 0;
	virtual EOculusXRBodyRetargetingRootMotionBehavior GetRootMotionBehavior() = 0;

	virtual void SetDebugPoseMode(const EOculusXRBodyDebugPoseMode mode) = 0;
	virtual void SetDebugDrawMode(const EOculusXRBodyDebugDrawMode mode) = 0;

	static bool IsRotationAndPositionRetargetingMode(EOculusXRBodyRetargetingMode mode)
	{
		return mode == EOculusXRBodyRetargetingMode::RotationAndPositions || mode == EOculusXRBodyRetargetingMode::RotationAndPositionsHandsRotationOnly;
	}

	static bool IsRotationOnlyRetargetingMode(EOculusXRBodyRetargetingMode mode)
	{
		return mode == EOculusXRBodyRetargetingMode::RotationOnlyUniformScale || mode == EOculusXRBodyRetargetingMode::RotationOnlyNoScaling;
	}

	static bool IsModifiedRootBehavior(EOculusXRBodyRetargetingRootMotionBehavior behavior)
	{
		return behavior != EOculusXRBodyRetargetingRootMotionBehavior::RootFlatTranslationHipRotation;
	}

	static bool IsHipOrRootSourceJoint(EOculusXRBoneID boneID)
	{
		return boneID == EOculusXRBoneID::BodyRoot || boneID == EOculusXRBoneID::BodyHips;
	}
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargeting.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(LogOculusXRRetargeting, Log, All);

class FOculusXRRetargetingModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargetingUtils.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once
#include "OculusXRLiveLinkRetargetBodyAsset.h"

struct OCULUSXRRETARGETING_API FOculusXRRetargetingUtils
{
	/**
	 * Converts from an EOculusXRAxis to an orientation quaternion of that direction
	 */
	static FTransform DirectionTransform(EOculusXRAxis Direction)
	{
		FVector Dir = FVector::ZeroVector;
		const uint8 IndexOfDir = static_cast<uint8>(Direction);
		const double Sign = IndexOfDir < static_cast<uint8>(EOculusXRAxis::NegativeX) ? 1 : -1;
		Dir[IndexOfDir % 3] = Sign * 1.0;
		return FTransform(Dir.ToOrientationQuat());
	}

	/**
	 * Get the transform from the tracking space to the component space
	 * @param ForwardTransform The forward transform of the mesh
	 */
	static FTransform GetTrackingSpaceToComponentSpace(const FTransform& ForwardTransform)
	{
		return DirectionTransform(ForwardTracking).Inverse() * ForwardTransform;
	}

	/**
	 * Compute the up and right axis for a bone based on the forward axis
	 */
	static FQuat LookRotation(FVector Forward)
	{
		Forward.Normalize();

		FVector Right = FVector::CrossProduct(FVector::UpVector, Forward);
		if (Right.SizeSquared() < KINDA_SMALL_NUMBER)
		{
			Right = FVector::RightVector;
		}
		else
		{
			Right.Normalize();
		}
		const FVector Up = FVector::CrossProduct(Forward, Right);
		const FMatrix RotMatrix(Forward, Right, Up, FVector::ZeroVector);

		return RotMatrix.Rotator().Quaternion();
	}

	/**
	 * Compute the up axis for a bone based on the forward and right axis
	 */
	static FQuat LookRotation(FVector Forward, FVector Right)
	{
		Forward.Normalize();
		Right.Normalize();

		const FVector Up = FVector::CrossProduct(Forward, Right);
		const FMatrix RotMatrix(Forward, Right, Up, FVector::ZeroVector);

		return RotMatrix.Rotator().Quaternion();
	}

	/**
	 * Returns the scale factor from the world settings
	 */
	static bool GetUnitScaleFactorFromSettings(UWorld* World, float& OutWorldToMeters);

private:
	/**
	 * Oculus tracking space is using +X as its forward direction.
	 */
	inline static EOculusXRAxis ForwardTracking = EOculusXRAxis::X;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovement/Public/OculusXRRetargetSkeleton.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once
#include "OculusXRMovementTypes.h"
#include "OculusXRBodyRetargeter.h"

struct OCULUSXRRETARGETING_API FAbstractRetargetSkeleton
{
	virtual ~FAbstractRetargetSkeleton() = default;
	virtual bool IsEmpty() const = 0;
	virtual int GetNumBones() const = 0;
	virtual bool IsValidIndex(const int BoneIndex) const = 0;
	virtual int GetParentBoneIndex(const int BoneIndex) const = 0;
	virtual const FTransform& GetLocalTransform(const int BoneIndex) const = 0;
	virtual const FTransform& GetComponentTransform(const int BoneIndex) const = 0;
};

template <typename T>
struct OCULUSXRRETARGETING_API TOculusXRRetargetSkeletonJoint
{
	T BoneId;
	int ParentIdx;
	FTransform LocalTransform;
	FTransform ComponentTransform;

	static void CalculateComponentToLocalSpace(TArray<TOculusXRRetargetSkeletonJoint<T>>& JointData)
	{
		// Calculate the local transforms from the component transforms
		for (int i = 0; i < JointData.Num(); ++i)
		{
			int ParentIdx = JointData[i].ParentIdx;
			JointData[i].LocalTransform = ParentIdx == INDEX_NONE ? JointData[i].ComponentTransform : // No Parent - Root Space
				JointData[i].ComponentTransform.GetRelativeTransform(JointData[ParentIdx].ComponentTransform);
		}
	}

	static void CalculateLocalToComponentSpace(TArray<TOculusXRRetargetSkeletonJoint<T>>& JointData)
	{
		// TODO: Fix to be more bulletproof - Based on an assumption that the Joint Entry array is
		// sorted from Parent to Child.  If it isn't, then the Parent Transform may not get calculated before the child.

		// Calculate the component transforms from the local transforms
		for (int i = 0; i < JointData.Num(); ++i)
		{
			int ParentIdx = JointData[i].ParentIdx;
			JointData[i].ComponentTransform = ParentIdx == INDEX_NONE ? JointData[i].LocalTransform : // No Parent - Root Space
				JointData[i].LocalTransform * JointData[ParentIdx].ComponentTransform;
		}
	}
};

/**
 * @brief A template struct for Oculus XR retarget skeleton.
 *
 * @tparam T The type of the bone IDs.
 */
template <typename T>
struct OCULUSXRRETARGETING_API TOculusXRRetargetSkeleton : FAbstractRetargetSkeleton
{
protected:
	/**
	 * @brief Construct a new TOculusXRRetargetSkeleton object. Empty Constructor
	 */

	TOculusXRRetargetSkeleton() {}

	/**
	 * @brief Construct a new TOculusXRRetargetSkeleton object.
	 *
	 * @param _JointData The array of joint data.
	 * @param InvalidJointID Value of an Invalid Joint ID
	 */
	TOculusXRRetargetSkeleton(
		const TArray<TOculusXRRetargetSkeletonJoint<T>>& _JointData, const T InvalidJointID)
		: JointData(_JointData)
	{
		for (int iBoneIdx = 0; iBoneIdx < JointData.Num(); ++iBoneIdx)
		{
			if (JointData[iBoneIdx].BoneId != InvalidJointID)
			{
				BoneIdToJointIdxMap.Add(JointData[iBoneIdx].BoneId, iBoneIdx);
			}
		}
	}

	/**
	 * @brief Copy Constructor - Construct a new TOculusXRRetargetSkeleton object.
	 *
	 * @param other - Instance of class to copy from
	 */
	TOculusXRRetargetSkeleton(const TOculusXRRetargetSkeleton<T>& other)
		: JointData(other.JointData)
		, BoneIdToJointIdxMap(other.BoneIdToJointIdxMap)
	{
	}

	// Assignment Operator
	TOculusXRRetargetSkeleton<T>& operator=(const TOculusXRRetargetSkeleton<T>& other)
	{
		this->JointData = other.JointData;
		this->BoneIdToJointIdxMap = other.BoneIdToJointIdxMap;
		return *this;
	}

	virtual const T& InvalidBoneID() const = 0;

private:
	TArray<TOculusXRRetargetSkeletonJoint<T>> JointData;
	TMap<T, int> BoneIdToJointIdxMap;

public:
	const TArray<TOculusXRRetargetSkeletonJoint<T>>& GetJointDataArray() const { return JointData; }

	/**
	 * @brief Get the number of bones.
	 *
	 * @return int The number of bones.
	 */
	virtual int GetNumBones() const override
	{
		return JointData.Num();
	}

	/**
	 * @brief Check if the bone index is valid.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return bool True if the bone index is valid, false otherwise.
	 */
	virtual bool IsValidIndex(const int BoneIndex) const override
	{
		return BoneIndex >= 0 && BoneIndex < JointData.Num();
	}

	/**
	 * @brief Get the bone index by bone ID.
	 *
	 * @param BoneId The bone ID.
	 * @return int The bone index.
	 */
	int GetBoneIndex(const T& BoneId) const
	{
		return (BoneIdToJointIdxMap.Contains(BoneId) ? BoneIdToJointIdxMap[BoneId] : INDEX_NONE);
	}

	/**
	 * @brief Returns true if the Skeleton Structure has no data.
	 */
	virtual bool IsEmpty() const override
	{
		return JointData.IsEmpty();
	}

	/**
	 * @brief Check if the bone ID is valid.
	 *
	 * @param BoneId The ID of the bone.
	 * @return bool True if the bone ID is valid, false otherwise.
	 */
	bool IsValid(const T& BoneId) const
	{
		return BoneId != InvalidBoneID();
	}

	/**
	 * @brief Check if the bone at the given index is valid.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return bool True if the bone at that index is valid, false otherwise.
	 */
	/*
	bool IsValid(const int BoneIndex) const
	{
		return IsValidIndex(BoneIndex) && IsValid(GetBoneId(BoneIndex));
	}
	*/

	/**
	 * @brief Get the bone ID by index.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return T The bone ID.
	 */
	T GetBoneId(const int BoneIndex) const
	{
		return IsValidIndex(BoneIndex) ? JointData[BoneIndex].BoneId : InvalidBoneID();
	}

	/**
	 * @brief Checks if the bone at the given index has a valid parent.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return bool True if the bone at the given index has a valid parent, false otherwise.
	 */
	bool HasParent(const int BoneIndex) const
	{
		if (!IsValidIndex(BoneIndex))
			return false;
		return IsValidIndex(GetParentBoneIndex(BoneIndex));
	}

	/**
	 * @brief Checks if the bone with the given ID has a parent.
	 *
	 * @param BoneId The ID of the bone.
	 * @return bool True if the bone with the given ID has a parent, false otherwise.
	 */
	bool HasParentBoneId(const T& BoneId) const
	{
		return HasParent(GetBoneIndex(BoneId));
	}

	/**
	 * @brief Get the parent bone index by bone index.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return int The parent bone index.
	 */
	virtual int GetParentBoneIndex(const int BoneIndex) const override
	{
		return IsValidIndex(BoneIndex) ? JointData[BoneIndex].ParentIdx : INDEX_NONE;
	}

	/**
	 * @brief Get the parent bone ID by bone ID.
	 *
	 * @param BoneId The bone ID.
	 * @return T The parent bone ID.
	 */
	T GetParentBoneId(const T& BoneId) const
	{
		const auto BoneIndex = GetBoneIndex(BoneId);
		const auto ParentBoneIndex = GetParentBoneIndex(BoneIndex);
		return GetBoneId(ParentBoneIndex);
	}

	/**
	 * @brief Get the local transform by bone index.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return FTransform The local transform.
	 */
	virtual const FTransform& GetLocalTransform(const int BoneIndex) const override
	{
		return IsValidIndex(BoneIndex) ? JointData[BoneIndex].LocalTransform : FTransform::Identity;
	}

	/**
	 * @brief Get the component transform by bone index.
	 *
	 * @param BoneIndex The index of the bone.
	 * @return FTransform The component transform.
	 */
	virtual const FTransform& GetComponentTransform(const int BoneIndex) const override
	{
		return IsValidIndex(BoneIndex) ? JointData[BoneIndex].ComponentTransform : FTransform::Identity;
	}
};

// Explicit instantiation of the TOculusXRRetargetSkeleton template for the relevant types.
// This is needed in order for the compiler to properly make sense of method overloads and the like

template struct OCULUSXRRETARGETING_API TOculusXRRetargetSkeleton<EOculusXRBoneID>;
struct OCULUSXRRETARGETING_API FOculusXRRetargetSkeletonEOculusXRBoneID final : TOculusXRRetargetSkeleton<EOculusXRBoneID>
{
	FOculusXRRetargetSkeletonEOculusXRBoneID() {}

	FOculusXRRetargetSkeletonEOculusXRBoneID(
		const TArray<TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>>& JointData)
		: TOculusXRRetargetSkeleton<EOculusXRBoneID>(JointData, EOculusXRBoneID::None)
	{
		// All arrays should have at least one element
		check(!IsEmpty());
	}

	// Copy Constructor
	FOculusXRRetargetSkeletonEOculusXRBoneID(const FOculusXRRetargetSkeletonEOculusXRBoneID& other)
		: TOculusXRRetargetSkeleton<EOculusXRBoneID>(other)
	{
	}

	// Assignment Operator
	FOculusXRRetargetSkeletonEOculusXRBoneID& operator=(const FOculusXRRetargetSkeletonEOculusXRBoneID& other)
	{
		TOculusXRRetargetSkeleton<EOculusXRBoneID>::operator=(other);
		return *this;
	}

	static const EOculusXRBoneID kINVALID_BONE_ID;
	virtual const EOculusXRBoneID& InvalidBoneID() const override { return kINVALID_BONE_ID; }
};

template struct OCULUSXRRETARGETING_API TOculusXRRetargetSkeleton<FCompactPoseBoneIndex>;
struct OCULUSXRRETARGETING_API FOculusXRRetargetSkeletonFCompactPoseBoneIndex final : TOculusXRRetargetSkeleton<FCompactPoseBoneIndex>
{
	FOculusXRRetargetSkeletonFCompactPoseBoneIndex(
		const TArray<TOculusXRRetargetSkeletonJoint<FCompactPoseBoneIndex>>& JointData)
		: TOculusXRRetargetSkeleton<FCompactPoseBoneIndex>(JointData, FCompactPoseBoneIndex(INDEX_NONE))
	{
		// All arrays should have at least one element
		check(!IsEmpty());
	}

	// Copy Constructor
	FOculusXRRetargetSkeletonFCompactPoseBoneIndex(const FOculusXRRetargetSkeletonFCompactPoseBoneIndex& other)
		: TOculusXRRetargetSkeleton<FCompactPoseBoneIndex>(other)
	{
	}

	// Assignment Operator
	FOculusXRRetargetSkeletonFCompactPoseBoneIndex& operator=(const FOculusXRRetargetSkeletonFCompactPoseBoneIndex& other)
	{
		TOculusXRRetargetSkeleton<FCompactPoseBoneIndex>::operator=(other);
		return *this;
	}

	static const FCompactPoseBoneIndex kINVALID_BONE_ID;
	virtual const FCompactPoseBoneIndex& InvalidBoneID() const override { return kINVALID_BONE_ID; }
};

namespace Factory
{
	/**
	 * @brief Create a TOculusXRRetargetSkeleton object from Oculus XR body skeleton.
	 *
	 * @param SourceReferenceSkeleton The source reference skeleton.
	 * @param TrackingSpaceToComponentSpace The transform from tracking space to component space.
	 * @return FOculusXRRetargetSkeletonEOculusXRBoneID A TOculusXRRetargetSkeleton object.
	 */
	FOculusXRRetargetSkeletonEOculusXRBoneID FromOculusXRBodySkeleton(
		const FOculusXRBodySkeleton& SourceReferenceSkeleton,
		const FTransform& TrackingSpaceToComponentSpace);

	/**
	 * @brief Create a TOculusXRRetargetSkeleton object from Oculus XR body state.
	 *
	 * @param SourceFrameSkeleton The current frame of the source skeleton.
	 * @param SourceReferenceSkeleton The reference skeleton of the source skeleton.
	 * @param TrackingSpaceToComponentSpace The transform from tracking space to component space.
	 * @param rootMotionBehavior The root motion behavior to be applied when caching the pose.
	 * @return FOculusXRRetargetSkeletonEOculusXRBoneID A TOculusXRRetargetSkeleton object.
	 */
	FOculusXRRetargetSkeletonEOculusXRBoneID FromOculusXRBodyState(
		const FOculusXRBodyState& SourceFrameSkeleton,
		const FOculusXRBodySkeleton& SourceReferenceSkeleton,
		const FTransform& TrackingSpaceToComponentSpace,
		const EOculusXRBodyRetargetingRootMotionBehavior rootMotionBehavior);

	/**
	 * @brief Create a TOculusXRRetargetSkeleton object from a reference skeleton.
	 *
	 * @param TargetBoneContainer The bone container of the target skeleton from which to create the TOculusXRRetargetSkeleton object.
	 * @return FOculusXRRetargetSkeletonFCompactPoseBoneIndex A TOculusXRRetargetSkeleton object.
	 */
	FOculusXRRetargetSkeletonFCompactPoseBoneIndex FromBoneContainer(
		const FBoneContainer& TargetBoneContainer);

	/**
	 * @brief Create a TOculusXRRetargetSkeleton object from an Array of BoneId/ComponentSpace Transform pairs and origin Skeleton.
	 *
	 * @param BaseSkeleton The skeleton the component transform Array is relative to
	 * @param ComponentSpaceTransforms An Array of Compoenent Space Transform Data matching the BaseSkeleton
	 * @return FOculusXRRetargetSkeletonFCompactPoseBoneIndex A FOculusXRRetargetSkeletonFCompactPoseBoneIndex object.
	 */
	FOculusXRRetargetSkeletonFCompactPoseBoneIndex FromComponentSpaceTransformArray(
		const FAbstractRetargetSkeleton& BaseSkeleton,
		const TArray<TTuple<FCompactPoseBoneIndex, FTransform, float>>& ComponentSpaceTransformPairs);

} // namespace Factory

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/OculusXRRetargetingEditor.Build.cs
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

using UnrealBuildTool;

public class OculusXRRetargetingEditor : ModuleRules
{
    public OculusXRRetargetingEditor(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "OculusXRRetargeting",
                "Core",
                "CoreUObject",
                "Engine",
                "InputCore",
                "IKRig",
                "IKRigDeveloper",
                "IKRigEditor",
                "OculusXRMovement"
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "AnimGraph",
                "AnimGraphRuntime",
                "BlueprintGraph",
                "UnrealEd",
            }
        );
    }
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRFacialExpressionMapFactory.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRFacialExpressionMapFactory.h"
#include "OculusXRFacialExpressionMap.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(OculusXRFacialExpressionMapFactory)

#define LOCTEXT_NAMESPACE "OculusXRFacialExpressionMapFactory"

UOculusXRFacialExpressionMapFactory::UOculusXRFacialExpressionMapFactory()
{
	bCreateNew = true;
	bEditAfterNew = true;
	SupportedClass = UOculusXRFacialExpressionMap::StaticClass();
	Struct = FOculusXRFacialExpressionMapRow::StaticStruct();
}

UObject* UOculusXRFacialExpressionMapFactory::FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)
{
	UOculusXRFacialExpressionMap* NewCustomDataTable = NewObject<UOculusXRFacialExpressionMap>(InParent, InClass, InName, Flags | RF_Transactional);
	NewCustomDataTable->RowStruct = const_cast<UScriptStruct*>(ToRawPtr(Struct));
	return NewCustomDataTable;
}

FText UOculusXRFacialExpressionMapFactory::GetDisplayName() const
{
	return LOCTEXT("OculusXRFacialExpressionMapFactoryDescription", "OculusXR Facial Expression Map Factory");
}

#undef LOCTEXT_NAMESPACE

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRRetargetIKRetargeterEditor.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetIKRetargeterEditor.h"
#include "Kismet2/CompilerResultsLog.h"

#include UE_INLINE_GENERATED_CPP_BY_NAME(OculusXRRetargetIKRetargeterEditor)

#define LOCTEXT_NAMESPACE "OculusXRRetargetIKRetargeterEditor"
const FName UOculusXRRetargetIKRetargeterEditor::AnimModeName(TEXT("IKRig.IKRigEditor.IKRigEditMode"));

void UOculusXRRetargetIKRetargeterEditor::Draw(FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* PreviewSkelMeshComp) const
{
}

FText UOculusXRRetargetIKRetargeterEditor::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("OculusXRRetargetIKRetargeterEditor_Title", "OculusXR Retarget IKRetargeter");
}

FEditorModeID UOculusXRRetargetIKRetargeterEditor::GetEditorMode() const
{
	return AnimModeName;
}

void UOculusXRRetargetIKRetargeterEditor::CustomizePinData(UEdGraphPin* Pin, FName SourcePropertyName, int32 ArrayIndex) const
{
	Super::CustomizePinData(Pin, SourcePropertyName, ArrayIndex);
}

UObject* UOculusXRRetargetIKRetargeterEditor::GetJumpTargetForDoubleClick() const
{
	return Node.IKRetargeterAsset;
}

void UOculusXRRetargetIKRetargeterEditor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
{
	const FName PropertyName = (PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None);
	if ((PropertyName == GET_MEMBER_NAME_STRING_CHECKED(FOculusXRRetargeterAnimNode, bUseAttachedParent)))
	{
		ReconstructNode();
	}
}

void UOculusXRRetargetIKRetargeterEditor::ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog)
{
	Super::ValidateAnimNodeDuringCompilation(ForSkeleton, MessageLog);

	// validate source mesh component is not null
	if (!Node.bUseAttachedParent)
	{
		const bool bIsLinked = IsPinExposedAndLinked(GET_MEMBER_NAME_STRING_CHECKED(FOculusXRRetargeterAnimNode, SourceMeshComponent));
		const bool bIsBound = IsPinExposedAndBound(GET_MEMBER_NAME_STRING_CHECKED(FOculusXRRetargeterAnimNode, SourceMeshComponent));
		if (!(bIsLinked || bIsBound))
		{
			MessageLog.Error(TEXT("@@ is missing a Source Skeletal Mesh Component reference."), this);
			return;
		}
	}

	// validate IK Rig asset has been assigned
	if (!Node.IKRetargeterAsset)
	{
		UEdGraphPin* Pin = FindPin(GET_MEMBER_NAME_STRING_CHECKED(FOculusXRRetargeterAnimNode, IKRetargeterAsset));
		if (Pin == nullptr)
		{
			// retarget asset unassigned
			MessageLog.Error(TEXT("@@ does not have an IK Retargeter asset assigned."), this);
		}
		return;
	}

	// validate SOURCE IK Rig asset has been assigned
	if (!Node.IKRetargeterAsset->GetSourceIKRig())
	{
		MessageLog.Warning(TEXT("@@ has IK Retargeter that is missing a source IK Rig asset."), this);
	}

	// validate TARGET IK Rig asset has been assigned
	if (!Node.IKRetargeterAsset->GetTargetIKRig())
	{
		MessageLog.Warning(TEXT("@@ has IK Retargeter that is missing a target IK Rig asset."), this);
	}

	if (!(Node.IKRetargeterAsset->GetSourceIKRig() && Node.IKRetargeterAsset->GetTargetIKRig()))
	{
		return;
	}

	// pull messages out of the processor's log
	if (!Node.bSuppressWarnings)
	{
		if (const UIKRetargetProcessor* Processor = Node.GetRetargetProcessor())
		{
			const TArray<FText>& Warnings = Processor->Log.GetWarnings();
			for (const FText& Warning : Warnings)
			{
				MessageLog.Warning(*Warning.ToString());
			}

			const TArray<FText>& Errors = Processor->Log.GetErrors();
			for (const FText& Error : Errors)
			{
				MessageLog.Error(*Error.ToString());
			}
		}
	}

	if (ForSkeleton && !Node.bSuppressWarnings)
	{
		// validate that target bone chains exist on this skeleton
		const FReferenceSkeleton& RefSkel = ForSkeleton->GetReferenceSkeleton();
		const TArray<FBoneChain>& TargetBoneChains = Node.IKRetargeterAsset->GetTargetIKRig()->GetRetargetChains();
		for (const FBoneChain& Chain : TargetBoneChains)
		{
			if (RefSkel.FindBoneIndex(Chain.StartBone.BoneName) == INDEX_NONE)
			{
				MessageLog.Warning(*FText::Format(LOCTEXT("StartBoneNotFound", "@@ - Start Bone '{0}' in target IK Rig Bone Chain not found."), FText::FromName(Chain.StartBone.BoneName)).ToString(), this);
			}

			if (RefSkel.FindBoneIndex(Chain.EndBone.BoneName) == INDEX_NONE)
			{
				MessageLog.Warning(*FText::Format(LOCTEXT("EndBoneNotFound", "@@ - End Bone '{0}' in target IK Rig Bone Chain not found."), FText::FromName(Chain.EndBone.BoneName)).ToString(), this);
			}
		}
	}
}

void UOculusXRRetargetIKRetargeterEditor::PreloadRequiredAssets()
{
	Super::PreloadRequiredAssets();

	if (Node.IKRetargeterAsset)
	{
		PreloadObject(Node.IKRetargeterAsset);
		PreloadObject(Node.IKRetargeterAsset->GetSourceIKRigWriteable());
		PreloadObject(Node.IKRetargeterAsset->GetTargetIKRigWriteable());
	}
}

#undef LOCTEXT_NAMESPACE

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Private/OculusXRRetargetingEditor.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetingEditor.h"
#include "Modules/ModuleManager.h"
#include "Modules/ModuleInterface.h"

IMPLEMENT_GAME_MODULE(FOculusXRRetargetingEditor, OculusRetargetingEditor);

DEFINE_LOG_CATEGORY(OculusXRRetargetingEditor)

#define LOCTEXT_NAMESPACE "OculusXRRetargetingEditor"

void FOculusXRRetargetingEditor::StartupModule()
{
	UE_LOG(OculusXRRetargetingEditor, Warning, TEXT("OculusXR Retargeting Editor: Log Started"));
}

void FOculusXRRetargetingEditor::ShutdownModule()
{
	UE_LOG(OculusXRRetargetingEditor, Warning, TEXT("OculusXR Retargeting: Log Ended"));
}

#undef LOCTEXT_NAMESPACE

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRFacialExpressionMapFactory.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "UObject/ObjectMacros.h"
#include "Factories/Factory.h"

#include "OculusXRFacialExpressionMapFactory.generated.h"

UCLASS(Category = "OculusXR")
class OCULUSXRRETARGETINGEDITOR_API UOculusXRFacialExpressionMapFactory : public UFactory
{
	GENERATED_BODY()

public:
	UPROPERTY()
	TObjectPtr<const class UScriptStruct> Struct;

	UOculusXRFacialExpressionMapFactory();

	virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;

	virtual FText GetDisplayName() const override;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRRetargetIKRetargeterEditor.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "UObject/ObjectMacros.h"
#include "AnimGraphNode_Base.h"
#include "OculusXRRetargeterAnimNode.h"
#include "OculusXRRetargetIKRetargeterEditor.generated.h"

class FPrimitiveDrawInterface;
class USkeletalMeshComponent;

// Editor node for IKRig
UCLASS()
class OCULUSXRRETARGETINGEDITOR_API UOculusXRRetargetIKRetargeterEditor : public UAnimGraphNode_Base
{
	GENERATED_BODY()

	UPROPERTY(EditAnywhere, Category = Settings)
	FOculusXRRetargeterAnimNode Node;

public:
	// UEdGraphNode interface
	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override;
	virtual void PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent) override;
	virtual void ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog);
	// End of UEdGraphNode interface

	// UAnimGraphNode_Base interface
	virtual void PreloadRequiredAssets() override;
	virtual FEditorModeID GetEditorMode() const override;
	virtual void Draw(FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* PreviewSkelMeshComp) const override;
	virtual void CustomizePinData(UEdGraphPin* Pin, FName SourcePropertyName, int32 ArrayIndex) const override;
	virtual bool UsingCopyPoseFromMesh() const override { return true; };
	// End of UAnimGraphNode_Base interface

	// UK2Node interface
	virtual UObject* GetJumpTargetForDoubleClick() const override;
	// End of UK2Node interface

	static const FName AnimModeName;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementEditor/Public/OculusXRRetargetingEditor.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "Modules/ModuleInterface.h"
#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(OculusXRRetargetingEditor, All, All)

class FOculusXRRetargetingEditor : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementGraph/OculusXRRetargetingGraph.Build.cs
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

using UnrealBuildTool;

public class OculusXRRetargetingGraph : ModuleRules
{
    public OculusXRRetargetingGraph(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(
            new string[]
            {
                "Core",
                "OculusXRRetargeting",
                "OculusXRMovement",
            }
        );

        PrivateDependencyModuleNames.AddRange(
            new string[]
            {
                "CoreUObject",
                "Engine",
                "AnimGraph",
                "AnimGraphRuntime",
                "BlueprintGraph",
            }
        );
    }
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Private/OculusXR_TrackingGraphNodes.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXR_TrackingGraphNodes.h"
#include "OculusXRMovementTypes.h"
#include "Misc/EnumRange.h"
#include <cctype>

ENUM_RANGE_BY_COUNT(EOculusXRBoneID, EOculusXRBoneID::COUNT);

void UOculusXR_BodyTracking::GenerateBoneMapping()
{
	FString SourceName;
	TArray<FName> BoneNames;
	const FReferenceSkeleton& RefSkeleton = GetAnimBlueprint()->TargetSkeleton->GetReferenceSkeleton();

	int32 NumBones = RefSkeleton.GetNum();
	for (int i = 0; i < NumBones; ++i)
	{
		BoneNames.Add(RefSkeleton.GetBoneName(i));
	}

	TMap<EOculusXRBoneID, FName> BoneMap;
	for (EOculusXRBoneID BoneID : TEnumRange<EOculusXRBoneID>())
	{
		int MaxMatches = 0;
		int NumSubstrings = 0;
		TSet<FString> Substrings;
		SourceName = StaticEnum<EOculusXRBoneID>()->GetNameStringByValue(static_cast<int64>(BoneID));

		for (FName TargetName : BoneNames)
		{
			Substrings = GetSubstringsBetweenJointNames(SourceName, TargetName.ToString(), MIN_SUBSTRING_LENGTH, FilterJoints);
			NumSubstrings = Substrings.Num();

			if (NumSubstrings > MaxMatches && CountSubstringsCharLength(Substrings) > (TargetName.ToString().Len() * FilterSensitivity))
			{
				MaxMatches = NumSubstrings;
				BoneMap.Add(BoneID, TargetName);
			}
		}
	}
	Node.BoneRemapping = BoneMap;
	MarkPackageDirty();
}

int UOculusXR_BodyTracking::CountSubstringsCharLength(const TSet<FString>& Substrings)
{
	int Result = 0;
	for (const FString& s : Substrings)
	{
		Result += s.Len();
	}
	return Result;
}

TSet<FString> UOculusXR_BodyTracking::GetSubstringsBetweenJointNames(FString sourceJointName, FString targetJointName, int minSubstringLength, TSet<FString> filterList)
{
	TSet<FString> commonSubstrings;

	int sourceIdx = sourceJointName.Len() - minSubstringLength;
	int targetIdx = 0;

	while (targetIdx < targetJointName.Len() - minSubstringLength)
	{
		int charsToCompare = std::min(sourceJointName.Len() - sourceIdx, targetJointName.Len() - targetIdx);
		int substringStart = -1;

		for (int i = 0; i < charsToCompare; i++)
		{
			if (std::tolower(sourceJointName[sourceIdx + i]) == std::tolower(targetJointName[targetIdx + i]))
			{
				// Check for an Uppercase termination of a word
				if (substringStart >= 0 && i > substringStart && ((std::isupper(sourceJointName[sourceIdx + i]) && !std::isupper(sourceJointName[sourceIdx + i - 1])) || (std::isupper(targetJointName[targetIdx + i]) && !std::isupper(targetJointName[targetIdx + i - 1]))))
				{
					if (i - substringStart >= minSubstringLength)
					{
						// Use the target space for capitalization
						FString foundSubstring = targetJointName.Mid(targetIdx + substringStart,
							i - substringStart);

						if (filterList.Contains(foundSubstring))
						{
							commonSubstrings.Add(foundSubstring);
						}
					}
					// Start a new subString
					substringStart = i;
				}
				else if (substringStart < 0)
				{
					substringStart = i;
				}
			}
			else if (substringStart >= 0)
			{
				if (i - substringStart >= minSubstringLength)
				{
					// Use the target space for capitalization
					FString foundSubstring = targetJointName.Mid(targetIdx + substringStart,
						i - substringStart);

					if (filterList.Contains(foundSubstring))
					{
						commonSubstrings.Add(foundSubstring);
					}
				}
				substringStart = -1;
			}
		}
		// We ended with a substring - store it
		if (substringStart >= 0 && charsToCompare - substringStart >= minSubstringLength)
		{
			FString foundSubstring = targetJointName.Mid(targetIdx + substringStart,
				charsToCompare - substringStart);

			if (filterList.Contains(foundSubstring))
			{
				commonSubstrings.Add(foundSubstring);
			}
		}
		if (sourceIdx > 0)
		{
			sourceIdx--;
		}
		else
		{
			targetIdx++;
		}
	}
	return commonSubstrings;
}

void UOculusXR_BodyTracking::ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog)
{
	Super::ValidateAnimNodeDuringCompilation(ForSkeleton, MessageLog);
}

FText UOculusXR_BodyTracking::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::FromString("OculusXR Body Tracking");
}

FText UOculusXR_BodyTracking::GetTooltipText() const
{
	return FText::FromString("This node is responsible for receiving the body tracking data from the HMD and applying it to the skeleton.");
}

FString UOculusXR_BodyTracking::GetNodeCategory() const
{
	return FString("OculusXR Body Tracking");
}

void UOculusXR_FaceTracking::ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog)
{
	Super::ValidateAnimNodeDuringCompilation(ForSkeleton, MessageLog);
}

FText UOculusXR_FaceTracking::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::FromString("OculusXR Face Tracking");
}

FText UOculusXR_FaceTracking::GetTooltipText() const
{
	return FText::FromString("This node is responsible for receiving the face tracking data from the HMD and applying it to the skeleton.");
}

FString UOculusXR_FaceTracking::GetNodeCategory() const
{
	return FString("OculusXR Face Tracking");
}

void UOculusXR_EyeTracking::ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog)
{
	Super::ValidateAnimNodeDuringCompilation(ForSkeleton, MessageLog);
}

FText UOculusXR_EyeTracking::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return FText::FromString("OculusXR Eye Tracking");
}

FText UOculusXR_EyeTracking::GetTooltipText() const
{
	return FText::FromString("This node is responsible for receiving the eye tracking data from the HMD and applying it to the skeleton.");
}

FString UOculusXR_EyeTracking::GetNodeCategory() const
{
	return FString("OculusXR Eye Tracking");
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Private/OculusXRRetargetingGraph.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetingGraph.h"

#define LOCTEXT_NAMESPACE "FOculusXRRetargetingGraphModule"

void FOculusXRRetargetingGraphModule::StartupModule()
{
}

void FOculusXRRetargetingGraphModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FOculusXRRetargetingGraphModule, OculusXRRetargetingGraph)

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Public/OculusXR_TrackingGraphNodes.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "AnimNode_OculusXRBodyTracking.h"
#include "AnimNode_OculusXRFaceTracking.h"
#include "AnimNode_OculusXREyeTracking.h"
#include "AnimGraphNode_Base.h"
#include "OculusXR_TrackingGraphNodes.generated.h"

/**
 * This node is responsible for receiving the body tracking data from the Oculus SDK and applying it to the skeleton.
 */
UCLASS()
class OCULUSXRRETARGETINGGRAPH_API UOculusXR_BodyTracking : public UAnimGraphNode_Base
{
	GENERATED_BODY()

	// TODO: Hide the input pose data as that is not being used or valid

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_OculusXRBodyTracking Node;

	UFUNCTION(CallInEditor, Category = Tools)
	void GenerateBoneMapping();

	UPROPERTY(EditAnywhere, Category = Tools, meta = (ClampMin = "0", ClampMax = "1"))
	float FilterSensitivity = 0.75;

	static const int MIN_SUBSTRING_LENGTH = 3;

	int CountSubstringsCharLength(const TSet<FString>& Substrings);

	TSet<FString> GetSubstringsBetweenJointNames(FString sourceJointName, FString targetJointName, int minSubstringLength = MIN_SUBSTRING_LENGTH, TSet<FString> filterList = {});

	UPROPERTY(EditAnywhere, Category = Tools)
	TSet<FString> FilterJoints = { "Root", "Hips", "Body", "Spine", "Lower", "Middle", "Upper", "Chest", "Neck", "Head", "Shoulder", "Arm", "Hand", "Leg", "Foot", "Left", "Right", "Thumb", "Index", "Ring", "Pinky", "Little", "Ball" };

	virtual void ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog) override;

	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override;

	virtual FText GetTooltipText() const override;

	virtual FString GetNodeCategory() const override;
};

/**
 * This node is responsible for receiving the body tracking data from the Oculus SDK and applying it to the skeleton.
 */
UCLASS()
class OCULUSXRRETARGETINGGRAPH_API UOculusXR_FaceTracking : public UAnimGraphNode_Base
{
	GENERATED_BODY()

	// TODO: Hide the input pose data as that is not being used or valid

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_OculusXRFaceTracking Node;

	virtual void ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog) override;

	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override;

	virtual FText GetTooltipText() const override;

	virtual FString GetNodeCategory() const override;
};

/**
 * This node is responsible for receiving the body tracking data from the Oculus SDK and applying it to the skeleton.
 */
UCLASS()
class OCULUSXRRETARGETINGGRAPH_API UOculusXR_EyeTracking : public UAnimGraphNode_Base
{
	GENERATED_BODY()

	// TODO: Hide the input pose data as that is not being used or valid

	UPROPERTY(EditAnywhere, Category = Settings)
	FAnimNode_OculusXREyeTracking Node;

	virtual void ValidateAnimNodeDuringCompilation(USkeleton* ForSkeleton, FCompilerResultsLog& MessageLog) override;

	virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override;

	virtual FText GetTooltipText() const override;

	virtual FString GetNodeCategory() const override;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementGraph/Public/OculusXRRetargetingGraph.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FOculusXRRetargetingGraphModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementTests/OculusXRRetargetingTests.Build.cs
================
using UnrealBuildTool;

public class OculusXRRetargetingTests : ModuleRules
{
    public OculusXRRetargetingTests(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

        PrivateDependencyModuleNames.AddRange(
            new[]
            {
                "Core",
                "OculusXRRetargeting",
                "OculusXRMovement"
            }
        );
    }
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/OculusXRRetargetingTests.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRRetargetingTests.h"

#define LOCTEXT_NAMESPACE "FOculusXRRetargetingTestsModule"

void FOculusXRRetargetingTestsModule::StartupModule()
{
}

void FOculusXRRetargetingTestsModule::ShutdownModule()
{
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FOculusXRRetargetingTestsModule, OculusXRRetargetingTests)

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/RetargetingSkeletonTests.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "RetargetingSkeletonTests.h"

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementTests/Private/RetargetingSkeletonTests.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "Misc/EngineVersionComparison.h"
#include "Misc/AutomationTest.h"
#include "OculusXRMovementTypes.h"
#include "OculusXRRetargetSkeleton.h"

#if UE_VERSION_OLDER_THAN(5, 5, 0)
#define RetargetSkeletonTestFilters EAutomationTestFlags::ApplicationContextMask | EAutomationTestFlags::SmokeFilter
#else
#define RetargetSkeletonTestFilters EAutomationTestFlags_ApplicationContextMask | EAutomationTestFlags::SmokeFilter
#endif // UE_VERSION_OLDER_THAN(5, 5, 0)

// These tests check that the simple operations of getting bone IDs, parent bone indices, local transforms, and component transforms work as expected.

inline TOculusXRRetargetSkeleton<EOculusXRBoneID>* CreateSkeleton()
{
	// Instantiate the class you want to test
	const TArray<TOculusXRRetargetSkeletonJoint<EOculusXRBoneID>> JointData = {
		{ EOculusXRBoneID::BodyRoot, INDEX_NONE, FTransform::Identity, FTransform::Identity },
		{ EOculusXRBoneID::BodyHips, 0, FTransform::Identity, FTransform::Identity },
	};

	return new FOculusXRRetargetSkeletonEOculusXRBoneID(JointData);
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FGetNumBones, "OculusXRRetargetingTests.FGetNumBones", RetargetSkeletonTestFilters)
inline bool FGetNumBones::RunTest(const FString& Parameters)
{
	const auto Skeleton = CreateSkeleton();

	// Test GetNumBones method
	TestEqual("Number of bones should be 2", Skeleton->GetNumBones(), 2);

	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FIsValidIndex, "OculusXRRetargetingTests.FIsValidIndex", RetargetSkeletonTestFilters)
inline bool FIsValidIndex::RunTest(const FString& Parameters)
{
	const auto Skeleton = CreateSkeleton();

	// Test IsValidIndex method
	TestFalse("Index -1 should be invalid", Skeleton->IsValidIndex(-1));
	TestFalse("INDEX_NONE should be invalid", Skeleton->IsValidIndex(INDEX_NONE));
	TestTrue("Index 0 should be valid", Skeleton->IsValidIndex(0));
	TestTrue("Index 1 should be valid", Skeleton->IsValidIndex(1));
	TestFalse("Index 2 should be invalid", Skeleton->IsValidIndex(2));

	return true;
}

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FHasParentTests, "OculusXRRetargetingTests.FHasParentTests", RetargetSkeletonTestFilters)
inline bool FHasParentTests::RunTest(const FString& Parameters)
{
	const auto Skeleton = CreateSkeleton();

	// Test HasParent method
	TestFalse("Index -1 should not have a parent", Skeleton->HasParent(-1));
	TestFalse("INDEX_NONE should not have a parent", Skeleton->HasParent(INDEX_NONE));
	TestFalse("Bone at index 0 should not have a parent", Skeleton->HasParent(0));
	TestTrue("Bone at index 1 should have a parent", Skeleton->HasParent(1));
	TestFalse("Index 2 should not have a parent", Skeleton->HasParent(2));

	TestFalse("BoneID NONE should not have a parent", Skeleton->HasParentBoneId(EOculusXRBoneID::None));
	TestFalse("BoneID BodyRoot should not have a parent", Skeleton->HasParentBoneId(EOculusXRBoneID::BodyRoot));
	TestTrue("BoneID BodyHips should have a parent", Skeleton->HasParentBoneId(EOculusXRBoneID::BodyHips));
	TestFalse("BoneID that is not present in the dataset should not have a parent", Skeleton->HasParentBoneId(EOculusXRBoneID::BodyHead));

	return true;
}

================
File: Plugins/OculusXRMovement/Source/OculusXRMovementTests/Public/OculusXRRetargetingTests.h
================
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

class FOculusXRRetargetingTestsModule : public IModuleInterface
{
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

================
File: Source/AlanMovement.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class AlanMovementTarget : TargetRules
{
	public AlanMovementTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_5;
		ExtraModuleNames.Add("AlanMovement");
	}
}

================
File: Source/AlanMovement/AlanMovement.Build.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class AlanMovement : ModuleRules
{
	public AlanMovement(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput", "OculusXRMovement" });

		PrivateDependencyModuleNames.AddRange(new string[] {  });

		// Uncomment if you are using Slate UI
		// PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
		
		// Uncomment if you are using online features
		// PrivateDependencyModuleNames.Add("OnlineSubsystem");

		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true
	}
}

================
File: Source/AlanMovement/AlanMovement.cpp
================
// Copyright Epic Games, Inc. All Rights Reserved.

#include "AlanMovement.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE(FDefaultGameModuleImpl, AlanMovement, "AlanMovement");

// Define the log category here.
DEFINE_LOG_CATEGORY(LogOculusXRMovementSample);

================
File: Source/AlanMovement/AlanMovement.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"

// Declare the log category once.
DECLARE_LOG_CATEGORY_EXTERN(LogOculusXRMovementSample, Log, All);

================
File: Source/AlanMovement/Private/OculusXRFaceCorrectiveNamingScheme.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRFaceCorrectiveNamingScheme.h"

TArray<TSharedPtr<ICorrectiveShape>> NamingScheme::ParseCorrectives(TArray<FName> MorphTargetNames)
{
	TArray<TSharedPtr<ICorrectiveShape>> CorrectiveShapes;

	auto CorrectiveFound = false;
	auto PartialInBetweens = new TArray<Partial*>();

	for (int shapeIndex = 0; shapeIndex < MorphTargetNames.Num(); shapeIndex++)
	{
		if (TSharedPtr<Combination> Combination = MakeShareable(new struct Combination); TryParseCombination(MorphTargetNames, shapeIndex, Combination))
		{
			CorrectiveShapes.Add(Combination);
			CorrectiveFound = true;
		}
		else if (Partial* InBetween = new struct Partial(); TryParseInBetween(MorphTargetNames, shapeIndex, InBetween))
		{
			PartialInBetweens->Add(InBetween);
			CorrectiveFound = true;
		}
		else if (CorrectiveFound)
		{
			UE_LOG(LogTemp, Error, TEXT("Found unparseable shape name %s and assumed driver shape after finding one or more valid corrective shapes."), *MorphTargetNames[shapeIndex].ToString())
		}
	}

	auto InBetweens = InBetween::BuildFromPartials(*PartialInBetweens);
	for (auto i = 0; i < InBetweens.Num(); i++)
	{
		auto inBetween = InBetweens[i];
		if (inBetween->DrivenTarget.IsValid() && inBetween->DriverTarget.IsValid() && !inBetween->InfluenceCurve.IsEmpty())
		{
			CorrectiveShapes.Add(inBetween);
		}
		else
			UE_LOG(LogTemp, Error, TEXT("Invalid InBetween Corrective"))
	}

	return CorrectiveShapes;
}

bool NamingSchemes::NamingSchemeV0::TryParseCombination(TArray<FName>& MorphTargetNames, int Index, TSharedPtr<Combination> Combination)
{
	const auto MorphTargetName = MorphTargetNames[Index];
	FRegexMatcher Matcher(FRegexPattern(TEXT("^([a-zA-Z0-9]{4,25}(_[a-zA-Z0-9]{4,25})+)(_([A-Z]{1,2}))?$")), MorphTargetName.ToString());

	// Return if no matches
	if (!Matcher.FindNext())
	{
		return false;
	}

	// TODO: Check if groups number is higher than 5

	FString ElementsWithUnderscore = Matcher.GetCaptureGroup(1);
	TArray<FString> Elements;

	// Split the string on the underscore character
	ElementsWithUnderscore.ParseIntoArray(Elements, TEXT("_"));

	FString Suffix = "";
	if (Matcher.GetCaptureGroup(4).Len() > 0)
	{
		Suffix = Matcher.GetCaptureGroup(4);
	}

	TArray<FName> DriverTargets;
	for (auto i = 0; i < Elements.Num(); i++)
	{
		auto Element = Elements[i];
		FName DriverName = FName(*Element);
		if (FName Result; FindDriver(MorphTargetNames, DriverName, Suffix, Result))
		{
			DriverTargets.Add(Result);
		}
		else
		{
			UE_LOG(LogTemp, Error, TEXT("Could not find shape %s"), *Element)
			return false;
		}
	}

	Combination->DrivenTarget = MorphTargetName;
	Combination->DriverTargets = TArray<FName>(DriverTargets);

	return true;
}

bool NamingSchemes::NamingSchemeV0::FindDriver(TArray<FName>& MorphTargetNames, FName& DriverName, FString Suffix, FName& Result)
{
	int DriverIndex = MorphTargetNames.IndexOfByKey(DriverName);
	if (DriverIndex != INDEX_NONE)
	{
		Result = MorphTargetNames[DriverIndex];
		return true;
	}

	if (Suffix.Len() > 2)
	{
		UE_LOG(LogTemp, Error, TEXT("Expected suffix of length 0-2, got %s"), *Suffix);
	}

	if (Suffix.Len() > 0)
	{
		FString DriverNameString = FString::Printf(TEXT("%s_%c"), *DriverName.ToString(), Suffix[0]);
		FName DriverNameFName(*DriverNameString);

		DriverIndex = MorphTargetNames.IndexOfByKey(DriverNameFName);
		if (DriverIndex != INDEX_NONE)
		{
			Result = MorphTargetNames[DriverIndex];
			return true;
		}
	}

	if (Suffix.Len() > 1)
	{
		FString DriverNameString = FString::Printf(TEXT("%s_%c"), *DriverName.ToString(), Suffix[1]);
		FName DriverNameFName(*DriverNameString);
		DriverIndex = MorphTargetNames.IndexOfByKey(DriverNameFName);

		if (DriverIndex != INDEX_NONE)
		{
			Result = MorphTargetNames[DriverIndex];
			return true;
		}

		FString DriverNameString2 = FString::Printf(TEXT("%s_%c"), *DriverName.ToString(), *Suffix);
		FName DriverNameFName2(*DriverNameString2);
		DriverIndex = MorphTargetNames.IndexOfByKey(DriverNameFName2);

		if (DriverIndex != INDEX_NONE)
		{
			Result = MorphTargetNames[DriverIndex];
			return true;
		}
	}

	return false;
}

bool NamingSchemes::NamingSchemeV0::TryParseInBetween(TArray<FName>& MorphTargetNames, int Index, Partial* InBetween)
{
	const auto MorphTargetName = MorphTargetNames[Index];

	FRegexMatcher Matcher(FRegexPattern(TEXT("^([a-zA-Z]+)([0-9]{2})(_([A-Z]{1,2}))?$")), MorphTargetName.ToString());

	if (!Matcher.FindNext())
	{
		return false;
	}

	// TODO: Check that we have at least 5 capture groups or throw an error

	FString DriverNameString = Matcher.GetCaptureGroup(1);
	FName DriverName(*DriverNameString);

	// The highest number from the naming scheme (25, 50, 75, 100)
	int32 PeakValue = FCString::Atoi(*Matcher.GetCaptureGroup(2));

	if (PeakValue <= 0 || PeakValue >= 100)
	{
		UE_LOG(LogTemp, Warning, TEXT("Parsed value in %s is outside of (0, 100): %d"), *MorphTargetName.ToString(), PeakValue);
		return false;
	}

	FString Suffix = "";
	if (Matcher.GetCaptureGroup(4).Len() > 0)
	{
		Suffix = Matcher.GetCaptureGroup(4);
	}
	FName Result;
	if (!FindDriver(MorphTargetNames, DriverName, Suffix, Result))
	{
		// combination = ; ????????
		UE_LOG(LogTemp, Error, TEXT("Could not find shape %s"), *DriverName.ToString())
		return false;
	}

	InBetween->DrivenTarget = MorphTargetName;
	InBetween->DriverTarget = Result;
	InBetween->PeakValue = static_cast<float>(PeakValue) * 0.01f;

	return true;
}

FString NamingSchemes::NamingSchemeV0::VersionName()
{
	return TEXT("V0");
}

================
File: Source/AlanMovement/Private/OculusXRFaceCorrectiveNamingScheme.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "OculusXRFaceCorrectives.h"

/**
 * The version of the naming scheme to use for parsing corrective shapes.
 */
UENUM(BlueprintType)
enum ENamingSchemeVersion : int
{
	V0 = 0,
	COUNT = 1 UMETA(Hidden)
};

/**
 * A naming scheme describes how to parse the various corrective shapes' ICorrectiveShape
 * representations from a list of shape names.
 */
class NamingScheme
{
public:
	virtual ~NamingScheme() = default;

	/**
	 * Parses all proved shape names looking for known corrective shapes. Shapes that are not
	 * parseable are assumed to be driver shapes, but a warning is surfaced if a driver is
	 * found after one or more correctives has already been found.
	 */
	TArray<TSharedPtr<ICorrectiveShape>> ParseCorrectives(TArray<FName> MorphTargetNames);

protected:
	/**
	 * Attempts to parse a usable Combination corrective out of the shape name at the given index.
	 */
	virtual bool TryParseCombination(TArray<FName>& MorphTargetNames, int Index, TSharedPtr<Combination> Combination) = 0;

	/**
	 * Attempts to parse a partial InBetween corrective out of the shape name at the given index.
	 */
	virtual bool TryParseInBetween(TArray<FName>& MorphTargetNames, int Index, Partial* InBetween) = 0;

	/**
	 * The human-readable name of this parsing version.
	 */
	virtual FString VersionName() = 0;
};

/**
 * A collection of naming schemes to be used for parsing corrective shapes.
 */
class NamingSchemes
{
public:
	/**
	 * The V0 corrective naming scheme.
	 */
	static NamingScheme* V0()
	{
		return new NamingSchemeV0();
	}

private:
	/**
	 * V0 implementation of the naming scheme.
	 */
	class NamingSchemeV0 final : public NamingScheme
	{
	public:
		NamingSchemeV0() = default;
		virtual ~NamingSchemeV0() override = default;

	protected:
		virtual bool TryParseCombination(TArray<FName>& MorphTargetNames, int Index, TSharedPtr<Combination> Combination) override;
		virtual bool TryParseInBetween(TArray<FName>& MorphTargetNames, int Index, Partial* InBetween) override;
		virtual FString VersionName() override;

	private:
		/**
		 * Searches a list of shape names for a given shape, trying different combinations of
		 * potential suffixes if the shape is not immediately found.
		 */
		static bool FindDriver(TArray<FName>& MorphTargetNames, FName& DriverName, FString Suffix, FName& Result);
	};
};

================
File: Source/AlanMovement/Private/OculusXRFaceCorrectives.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRFaceCorrectives.h"

Combination::Combination(const FName DrivenTarget, const TArray<FName>& DriverTargets)
{
	this->DrivenTarget = DrivenTarget;
	this->DriverTargets = DriverTargets;
}

void Combination::Apply(FOculusXRMorphTargetsController& Controller)
{
	// Multiplies all driver values together to get the product
	float Product = 1.0f;
	for (int i = 0; i < this->DriverTargets.Num(); i++)
	{
		const auto Driver = this->DriverTargets[i];	  // Name of driver
		Product *= Controller.GetMorphTarget(Driver); // Multiply by driver value
	}

	Controller.SetMorphTarget(DrivenTarget, Product); // Set driven value to product
}

InBetween::InBetween(const FName DriverTarget, const FName DrivenTarget, const FRichCurve& InfluenceCurve)
{
	this->DriverTarget = DriverTarget;
	this->DrivenTarget = DrivenTarget;
	this->InfluenceCurve = InfluenceCurve;
}

void InBetween::Apply(FOculusXRMorphTargetsController& Controller)
{
	// Get the weight of the driver
	const float DriverWeight = Controller.GetMorphTarget(DriverTarget);
	// Sample the curve and set driven value
	Controller.SetMorphTarget(DrivenTarget, this->InfluenceCurve.Eval(DriverWeight));
}

TArray<TSharedPtr<InBetween>> InBetween::BuildFromPartials(TArray<Partial*> Partials)
{
	TMap<FName, TArray<Partial>> GroupedPartials;

	// Group Partials by driver index in order to easier find
	// which Driver target maps to multiple Driven targets
	for (int i = 0; i < Partials.Num(); i++)
	{
		Partial* Partial = Partials[i];
		GroupedPartials.FindOrAdd(Partial->DriverTarget).Add(*Partial);
	}

	TArray<TSharedPtr<InBetween>> InBetweens;

	// Construct a curve for each group of Partials
	// This curve will determine how the much the Driver influences the Driven target
	for (auto& KeyValuePair : GroupedPartials)
	{
		TArray<Partial>& Subshapes = KeyValuePair.Value;
		// Sort subshapes by peak value in order to create the influence curve
		Subshapes.Sort([](const Partial& A, const Partial& B) {
			return A.PeakValue < B.PeakValue;
		});

		for (int32 i = 0; i < Subshapes.Num(); ++i)
		{
			TArray<FRichCurveKey> Keys;
			Keys.Add(FRichCurveKey(0.0f, 0.0f));

			if (i != 0)
			{
				Keys.Add(FRichCurveKey(Subshapes[i - 1].PeakValue, 0.0f));
			}

			Keys.Add(FRichCurveKey(Subshapes[i].PeakValue, 1.0f));

			if (i < Subshapes.Num() - 1)
			{
				Keys.Add(FRichCurveKey(Subshapes[i + 1].PeakValue, 0.0f));
			}

			Keys.Add(FRichCurveKey(1.0f, 0.0f));

			FRichCurve Curve;
			for (const FRichCurveKey& Key : Keys)
			{
				Curve.AddKey(Key.Time, Key.Value);
			}

			TSharedPtr<InBetween> InBetweenPtr = MakeShareable(new InBetween(KeyValuePair.Key, Subshapes[i].DrivenTarget, MoveTemp(Curve)));
			InBetweens.Add(InBetweenPtr);
		}
	}

	return InBetweens;
}

================
File: Source/AlanMovement/Private/OculusXRFaceCorrectives.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "OculusXRMorphTargetsController.h"

/**
 * An interface for corrective shapes.
 */
class ICorrectiveShape
{
public:
	/**
	 * Calculate the weight of this corrective shape and apply it to the shape (or shapes)
	 * it drives.
	 */
	virtual void Apply(FOculusXRMorphTargetsController& Controller) = 0;
};

/**
 * Defines a combination target.
 */
struct Combination final : ICorrectiveShape
{
public:
	Combination() = default;
	Combination(const FName DrivenTarget, const TArray<FName>& DriverTargets);
	virtual ~Combination() = default;

	/** The MorphTarget name to be driven on the skinned mesh renderer. */
	FName DrivenTarget;

	/** The MorphTarget names used in calculating the final weight for the driven MorphTarget. */
	TArray<FName> DriverTargets;

	virtual void Apply(FOculusXRMorphTargetsController& Controller) override;
};

/**
 * Parsed data for a single inbetween (that may belong to a group of in-betweens for a
 * shared driver shape).
 *
 * This is used as an intermediate representation for building InBetweens.
 */
struct Partial
{
	FName DriverTarget;
	FName DrivenTarget;
	float PeakValue;
};

/**
 * Defines an in-between. More specifically, defines a single in-between (i.e. jawDrop50) that
 * has a single peak.
 */
struct InBetween final : ICorrectiveShape
{
public:
	virtual ~InBetween() = default;

	/** The target blendshape index used for calculating the blendshape weight. */
	FName DriverTarget;

	/** The blendshape index to be driven on the skinned mesh renderer. */
	FName DrivenTarget;

	/** A curve describing how this inbetween's weight should vary with the driver. */
	FRichCurve InfluenceCurve;

	virtual void Apply(FOculusXRMorphTargetsController& Controller) override;

	/**
	 * Constructs a list of independently usable InBetweens by inferring their influence
	 * curves' keyframes based on other Partials for the same driver index.
	 */
	static TArray<TSharedPtr<InBetween>> BuildFromPartials(TArray<Partial*> Partials);

private:
	/**
	 * InBetweens should be constructed via BuildFromPartials to ensure the correct curves are
	 * being set for groupings of InBetweens.
	 */
	InBetween(const FName DriverTarget, const FName DrivenTarget, const FRichCurve& InfluenceCurve);
};

================
File: Source/AlanMovement/Private/OculusXRFaceTrackingCorrectives.cpp
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#include "OculusXRFaceTrackingCorrectives.h"
#include "OculusXRFaceCorrectiveNamingScheme.h"
#include "AlanMovement/AlanMovement.h"

// Sets default values for this component's properties
UOculusXRFaceTrackingCorrectives::UOculusXRFaceTrackingCorrectives()
{
	// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features
	// off to improve performance if you don't need them.
	PrimaryComponentTick.bCanEverTick = true;

	bUseCorrectives = true;
	NamingSchemeVersion = V0;

	TargetMeshComponent = nullptr;
}

// Called when the game starts
void UOculusXRFaceTrackingCorrectives::BeginPlay()
{
	Super::BeginPlay();

	if (!InitializeCorrectives())
	{
		UE_LOG(LogOculusXRMovementSample, Warning, TEXT("Could not initialize correctives. (%s:%s)"), *GetOwner()->GetName(), *GetName());
		SetComponentTickEnabled(false);
		return;
	}
}

bool UOculusXRFaceTrackingCorrectives::InitializeCorrectives()
{
	TargetMeshComponent = Cast<USkinnedMeshComponent>(GetOwner()->GetComponentByClass(USkinnedMeshComponent::StaticClass()));

	if (!IsValid(TargetMeshComponent))
	{
		UE_LOG(LogOculusXRMovementSample, Warning, TEXT("Could not find skeletal mesh component on this actor: (%s)"), *GetOwner()->GetName());
		return false;
	}

	if (TargetMeshComponent == nullptr)
	{
		return false;
	}

	USkeletalMesh* TargetMesh = Cast<USkeletalMesh>(TargetMeshComponent->GetSkinnedAsset());
	if (TargetMesh == nullptr)
	{
		return false;
	}

	const auto MorphTargetsRaw = TargetMesh->GetMorphTargets();

	TArray<FName> MorphTargetNames;

	// Collect all the morph target names
	for (int i = 0; i < MorphTargetsRaw.Num(); i++)
	{
		auto MorphTargetName = FName(MorphTargetsRaw[i].GetName());
		// Store them into an array to avoid calling GetMorphTargets() every tick
		MorphTargetNames.Add(MorphTargetName);
	}

	// Parse the correctives
	NamingScheme* NamingScheme;
	switch (NamingSchemeVersion)
	{
		case V0:
			NamingScheme = NamingSchemes::V0();
			break;
		default:
			UE_LOG(LogOculusXRMovementSample, Warning, TEXT("Trying to parse correctives with unsupported naming scheme version (%s:%s)"), *GetOwner()->GetName(), *GetName());
			return false;
	}
	Correctives = NamingScheme->ParseCorrectives(MorphTargetNames);
	delete NamingScheme;

	return true;
}

// Called every frame
void UOculusXRFaceTrackingCorrectives::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

	// WARNING: This component needs to update after OculusXRFaceTrackingComponent as this is a post-processing step.
	// The order should be set in the parent actor blueprint.
	if (bUseCorrectives)
	{
		for (int i = 0; i < Correctives.Num(); i++)
		{
			Correctives[i]->Apply(MorphTargets);
		}
		MorphTargets.ApplyMorphTargets(TargetMeshComponent);
	}
}

================
File: Source/AlanMovement/Private/OculusXRFaceTrackingCorrectives.h
================
/*
Copyright (c) Meta Platforms, Inc. and affiliates.
All rights reserved.

This source code is licensed under the license found in the
LICENSE file in the root directory of this source tree.
*/

#pragma once

#include "CoreMinimal.h"
#include "OculusXRFaceCorrectiveNamingScheme.h"
#include "OculusXRFaceCorrectives.h"
#include "Components/ActorComponent.h"
#include "OculusXRFaceTrackingCorrectives.generated.h"

UCLASS(ClassGroup = (Custom), meta = (BlueprintSpawnableComponent))
class UOculusXRFaceTrackingCorrectives : public UActorComponent
{
	GENERATED_BODY()

public:
	// Sets default values for this component's properties
	UOculusXRFaceTrackingCorrectives();

	// Called every frame
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
	/**
	 * If true, the correctives driver will apply correctives.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OculusXR|Movement")
	bool bUseCorrectives;

	/*
	 * Determines which naming scheme to use for the correctives.
	 */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "OculusXR|Movement")
	TEnumAsByte<ENamingSchemeVersion> NamingSchemeVersion;

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

private:
	bool InitializeCorrectives();

	// The mesh component targeted for expressions
	UPROPERTY()
	USkinnedMeshComponent* TargetMeshComponent;

	// Morph targets controller
	FOculusXRMorphTargetsController MorphTargets;

	/**
	 * Collection of correctives to be used on the morph targets.
	 * This turns some MorphTargets into drivers for other MorphTargets.
	 */
	TArray<TSharedPtr<ICorrectiveShape>> Correctives;
};

================
File: Source/AlanMovementEditor.Target.cs
================
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class AlanMovementEditorTarget : TargetRules
{
	public AlanMovementEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V5;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_5;
		ExtraModuleNames.Add("AlanMovement");
	}
}



================================================================
End of Codebase
================================================================
